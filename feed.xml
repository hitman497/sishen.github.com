<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Do Great Things - 叶玎玎</title>
  <subtitle> 叶玎玎在技术、创业、团队协作和项目管理上的思考和分享</subtitle>
  <id>http://yedingding.com</id>
  <link href="http://yedingding.com/"/>
  <link href="http://yedingding.com/feed.xml" rel="self"/>
  <updated>2014-05-15T05:04:00Z</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>采访《七周七数据库》作者 Eric Redmond - 数据库的故事 </title>
    <link rel="alternate" href="/2014/05/15/database-with-eric-redmond.html"/>
    <id>/2014/05/15/database-with-eric-redmond.html</id>
    <published>2014-05-15T05:04:00Z</published>
    <updated>2014-05-15T05:04:00Z</updated>
    <author>
      <name>叶玎玎</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;aside class="aside"&gt;&lt;img alt="AngularJS" src="/images/database-with-eric-redmond/database.jpg?1400134984"&gt;&lt;/aside&gt;&lt;/p&gt;

&lt;blockquote&gt;
  目前 Teahour 的网站不适合放文本，需要重新设计，暂时先放我自己博客上。
&lt;/blockquote&gt;

&lt;p&gt;本期音频文本非常感谢&lt;a href="http://weibo.com/wuyicun"&gt;@吴怡村&lt;/a&gt;的整理。本文是 Teahour 第 18 期 &lt;a href="http://teahour.fm/2013/06/03/databases-with-eric-redmond.html"&gt;『Interview with Eric Redmond about Database』&lt;/a&gt; 的录音文本，欢迎大家订阅 Teahour，iTunes URL 是 &lt;a href="http://itunes.apple.com/cn/podcast/teahour.fm/id608387170?l=en"&gt;http://itunes.apple.com/cn/podcast/teahour.fm/id608387170&lt;/a&gt;。Android 用户可以使用 &lt;a href="http://m.coolapk.com/apk/de.danoeh.antennapod"&gt;AntennaPod&lt;/a&gt; 来订阅。同时，欢迎加 Teahour 好友，&lt;a href="http://weibo.com/teahourfm"&gt;微博&lt;/a&gt;和 &lt;a href="https://twitter.com/teahourfm"&gt;Twitter&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;audio controls name="media"&gt;&lt;source src="http://screencasts.b0.upaiyun.com/podcasts/teahour_episode_18.m4a" type="audio/mpeg"&gt;&lt;/source&gt;&lt;/audio&gt;&lt;/p&gt;

&lt;h4&gt;Part 1: Introduction and the CAP theorem&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Welcome everybody! In this episode, we have &lt;a href="http://coderoshi.com/"&gt;Eric Redmond&lt;/a&gt; with us. I’m your host &lt;a href="http://knwang.com/"&gt;Kevin&lt;/a&gt; and we also have &lt;a href="http://yedingding.com/"&gt;Dingding&lt;/a&gt;. Eric, why don’t you introduce yourself first?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Sure, as you’ve mentioned, I’m Eric Redmond. I’m relevant to this episode. I co-authored a book with &lt;a href="https://twitter.com/hexlib"&gt;Jim Wilson&lt;/a&gt; called &lt;a href="http://pragprog.com/book/rwdata/seven-databases-in-seven-weeks"&gt;Seven Databases in Seven Weeks&lt;/a&gt;. And the idea was that with all the changes that have been recurring in the database marketplace over the past few years, it was probably the single...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;aside class="aside"&gt;
  &lt;img alt="AngularJS" src="/images/database-with-eric-redmond/database.jpg?1400134984" /&gt;
&lt;/aside&gt;&lt;/p&gt;

&lt;blockquote&gt;
  目前 Teahour 的网站不适合放文本，需要重新设计，暂时先放我自己博客上。
&lt;/blockquote&gt;

&lt;p&gt;本期音频文本非常感谢&lt;a href="http://weibo.com/wuyicun"&gt;@吴怡村&lt;/a&gt;的整理。本文是 Teahour 第 18 期 &lt;a href="http://teahour.fm/2013/06/03/databases-with-eric-redmond.html"&gt;『Interview with Eric Redmond about Database』&lt;/a&gt; 的录音文本，欢迎大家订阅 Teahour，iTunes URL 是 &lt;a href="http://itunes.apple.com/cn/podcast/teahour.fm/id608387170?l=en"&gt;http://itunes.apple.com/cn/podcast/teahour.fm/id608387170&lt;/a&gt;。Android 用户可以使用 &lt;a href="http://m.coolapk.com/apk/de.danoeh.antennapod"&gt;AntennaPod&lt;/a&gt; 来订阅。同时，欢迎加 Teahour 好友，&lt;a href="http://weibo.com/teahourfm"&gt;微博&lt;/a&gt;和 &lt;a href="https://twitter.com/teahourfm"&gt;Twitter&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;audio controls name="media"&gt;
  &lt;source src="http://screencasts.b0.upaiyun.com/podcasts/teahour_episode_18.m4a" type="audio/mpeg"&gt;
&lt;/audio&gt;&lt;/p&gt;

&lt;h4&gt;Part 1: Introduction and the CAP theorem&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Welcome everybody! In this episode, we have &lt;a href="http://coderoshi.com/"&gt;Eric Redmond&lt;/a&gt; with us. I&amp;rsquo;m your host &lt;a href="http://knwang.com/"&gt;Kevin&lt;/a&gt; and we also have &lt;a href="http://yedingding.com/"&gt;Dingding&lt;/a&gt;. Eric, why don&amp;rsquo;t you introduce yourself first?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Sure, as you&amp;rsquo;ve mentioned, I&amp;rsquo;m Eric Redmond. I&amp;rsquo;m relevant to this episode. I co-authored a book with &lt;a href="https://twitter.com/hexlib"&gt;Jim Wilson&lt;/a&gt; called &lt;a href="http://pragprog.com/book/rwdata/seven-databases-in-seven-weeks"&gt;Seven Databases in Seven Weeks&lt;/a&gt;. And the idea was that with all the changes that have been recurring in the database marketplace over the past few years, it was probably the single best way we knew to try and communicate all of these changes: by just teaching different databases that correspond to different styles. So in the book, as an example of relational databases, we had &lt;a href="http://www.postgresql.org/"&gt;Postgres&lt;/a&gt;, and as an example of key-value storage of two different kinds; we had &lt;a href="https://basho.com/riak"&gt;Riak&lt;/a&gt; and &lt;a href="http://redis.io/"&gt;Redis&lt;/a&gt;; for column-oriented data stores we had &lt;a href="http://hbase.apache.org/"&gt;HBase&lt;/a&gt; and a couple document data stores with &lt;a href="http://couchdb.apache.org/"&gt;Couch&lt;/a&gt; and &lt;a href="http://www.mongodb.org/"&gt;Mongo&lt;/a&gt;, and a graph data store with &lt;a href="http://www.neo4j.org/"&gt;Neo4j&lt;/a&gt;. Other than that, I actually work for a company &lt;a href="https://basho.com"&gt;Basho&lt;/a&gt; that makes one of the databases: Riak. Strangely enough, until I wrote this book, I had not even heard of it and I was so impressed with the design. I even mentioned in the book that out of all of these databases it was the one that struck me as one of the most architecturally elegant of the distributed styles that I just couldn&amp;rsquo;t say enough positive things. Finally I was just saying so many positive things I guess they decided to pay me for it. So now I work at Basho.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: OK, so maybe (let&amp;rsquo;s talk about) something about your background. Why are you all of a sudden interested in databases?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Well, like most things. It seems like all of a sudden but there&amp;rsquo;s a long and boring history behind it. No, I&amp;rsquo;ve actually been working in databases since college at &lt;a href="http://www.purdue.edu/"&gt;Purdue&lt;/a&gt;. I worked in (of course at that time, relational databases were the only real options anybody had) specifically Postgres; that&amp;rsquo;s where I did a lot of my work and even more specifically than that, high-dimensional indexing: the ability to index multimedia data by mapping it to a point in n-dimensional space was the focus of our research at the time. It&amp;rsquo;s interesting now in retrospect how almost silly that was. There are so many more efficient ways of mapping high-dimensional data than simply plotting a point in 5,000 dimensional features of vector space and doing a nearest neighbour search on it but it was still really interesting. It was sort of my first foray into this world as an undergrad.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: OK, so you actually did some research on database in university.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Whoa, whoa (let&amp;rsquo;s) back up. My name is not on any papers. I definitely wouldn&amp;rsquo;t go as far as saying I did research. I was an undergrad that helped with a lot of this research though.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: OK, just to be accurate on the record.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dingding&lt;/strong&gt;: This is Dingding. So (about) your book &lt;em&gt;Seven Database in Seven Weeks&lt;/em&gt;, I&amp;rsquo;m just curious that why it&amp;rsquo;s seven, not six and not eight?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: That&amp;rsquo;s a good question. Actually, there was a book preceeding this by an author Bruce Tate called &lt;a href="http://pragprog.com/book/btlang/seven-languages-in-seven-weeks"&gt;Seven Languages in Seven Weeks&lt;/a&gt; and the theory was very similar that if you learn all these different types of programming languages that will give you a very good overview of the programming language ecosystem. He&amp;rsquo;s the one that picked the number and we just stuck with it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: That actually is a very nice book and very mind-expanding. I think your book will be following a very similar pattern: just seven representative databases in different genres.&lt;/p&gt;

&lt;p&gt;So when you graduated, did you start as a database guy?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: No, I graduated right at the end of the dotcom boom: right when the dotcom era crashed (at) end of 2002, so I got whatever job I could. As much as I would have love to get into data management, I actually try to interview with Google. At that time, they had less than 100 employees but since I didn&amp;rsquo;t have a PhD or anything, they weren&amp;rsquo;t really interested. Although big data management, even at that time, was something I was very interested in. But I just took whatever job I could and I ended up being a software engineer for a few years and finally I was able to fall back into the database world: originally working for a company that does Mongo hosting called &lt;a href="https://www.mongohq.com/"&gt;MongoHQ&lt;/a&gt; then from there moved on over to Basho to work on Riak.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: OK. I want to start this discussion of databases with the &lt;a href="http://en.wikipedia.org/wiki/CAP_theorem"&gt;CAP theorem&lt;/a&gt;; I actually heard this from you. I think that would lay a pretty good foundation when we talk about each genre of databases. Why don&amp;rsquo;t you talk about this CAP theorem?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Sure. There&amp;rsquo;s a lot of theory to know about distributed systems in general and those that manage data in particular. A lack of knowledge of these details have been bringing people to make wild claims like 100% up-time guarantees or what I think is even crazier that is that CAP doesn&amp;rsquo;t matter. You&amp;rsquo;re starting to hear this trope quite often now. Really, the cornerstone of all distributed databases is the CAP theorem. The CAP theorem: C stands for consistency, A stands for availability and P is partition-tolerance. I&amp;rsquo;ll start with partition-tolerance first. This means a system that can tolerate a network partition, meaning lost network packets, which is always a possibility. Effectively, partition-tolerance means your system is distributed. If it&amp;rsquo;s possible to have two computers on a network where one tries to communicate to another one and that signal can be lost. If it can be lost, that&amp;rsquo;s a network partition. In the simplest case where you have two computers and one cable running between them, if you just take a pair of scissors and you cut that cable, you now have two computers that are effectively their own little sub-networks because they can&amp;rsquo;t talk to each other any more. You can heal that partition eventually (take a bunch of electrical tape and fix that cable) but that possibility is always there. So as far as the P (partition-tolerance), this is something that&amp;rsquo;s not optional if it&amp;rsquo;s a distributed system. So the layman definition of the CAP theorem is: between consistency, availability and partition-tolerance, you can only have two of them. But really, what it actually is, is that if you have a distributed system, you have to choose between consistency or availability. Now, not to belabour the P part but P really is the keystone of all distributed system problems. If it weren&amp;rsquo;t for the possibility of partitions, creating a consistent and available distributed database would actually be trivial. For concept of such painful importance, you would think it would deserve some fancy Greek letter like ∏, but now it&amp;rsquo;s just P. Now I sort of glossed over consistency and availability, I&amp;rsquo;ll try and explain using just a quick little story about why you can only have one of the two. So imagine you have three men that are sitting at a bar and the bartender gives each of the men a whiskey, then if you walk up to any of the man and ask what was your last drink, they would of course say whiskey. Now let&amp;rsquo;s say one of the three men gets up to go to the bathroom. In distributed system&amp;rsquo;s speak, he&amp;rsquo;s been partitioned from the group. He can&amp;rsquo;t communicate with them because he&amp;rsquo;s in the hallway walking to the bathroom. Now while he&amp;rsquo;s gone, walking away, the bartender gives the two men that are still sitting at the bar a beer but now we have a problem because depending on who I ask, either a man at the bar or the one on the way to the bathroom, I&amp;rsquo;ll get a different answer to the question of what was your most recent drink. So what this means is the three men would give inconsistent answers because as a system what you want is a system where no matter who you ask, you always get the same answer. That&amp;rsquo;s what consistency means. But the man on his way to the bathroom could say I&amp;rsquo;m a minority here, I can&amp;rsquo;t reach consensus with my friends so I&amp;rsquo;ll just refuse to answer. So in other words, he&amp;rsquo;s now unavailable. He&amp;rsquo;s unavailable to answer your question. Not that he&amp;rsquo;s down or he&amp;rsquo;s crashed or anything. It&amp;rsquo;s a conscious decision on his part to not answer that question because that way he&amp;rsquo;s not inconsistent: he&amp;rsquo;s just not answering and that&amp;rsquo;s the decision that must be made. You can either be consistent but unavailable, or you can be available but inconsistent in the face of a partition, but you can&amp;rsquo;t be both at the same. So that&amp;rsquo;s sort of my parable of the CAP theorem and on why you have to pick consistency or availability but you can&amp;rsquo;t have both.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: So using your analogy, if that man chooses to be available, then his answer may not be correct.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Right, it could be inconsistent because the last drink he had was whiskey. But (for) the other guys, the last drink they had was beer so they would give you inconsistent answers if you ask the wrong one. The problem is you never know which one you&amp;rsquo;re asking. Now remember I&amp;rsquo;ve said that the man can decide that he&amp;rsquo;s a minority and can&amp;rsquo;t reach consensus so he&amp;rsquo;ll just refuse to answer. This is actually how some databases like Mongo work: they will vote on a master. The master is the one that gets to communicate. But a master can only be elected to be the one to answer questions if it&amp;rsquo;s in a majority. So if a network partition occurs, the minority has just lost the ability to be elected. In the CAP theorem sense, hypothetically Mongo could remain consistent. I&amp;rsquo;m not going to speak to whether it will remain consistent because this is a technical issue and working for a competitor I probably shouldn&amp;rsquo;t exactly go into any sort of rant about whether it&amp;rsquo;s consistent but it could be.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: OK. But it can&amp;rsquo;t be both consistent and available.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Right. That said, that doesn&amp;rsquo;t mean that a system can&amp;rsquo;t be neither. It could be neither consistent nor available and there are databases that are like that.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: What&amp;rsquo;s the point for that?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Well, there are ones that were designed this way. &lt;a href="http://www.mpi-sws.org/~druschel/courses/ds/papers/cooper-pnuts.pdf"&gt;PNUTS&lt;/a&gt; is one of the more famous examples and they do it for lower latency because they don&amp;rsquo;t actually need either. They just want to be as fast as possible. But there are others that are neither consistent nor available just by broken design basically. These are really hard problems and it&amp;rsquo;s one of those things. We&amp;rsquo;re talking about edge cases so it really depends on the size of your clusters. Some people will run three machines and they&amp;rsquo;ll be fine most of the time. I actually spoke with a potential customer a few weeks ago. When I even said what if one of your current setup breaks and they said, well we&amp;rsquo;ll be down for a minute and we&amp;rsquo;ll fire up another one and we&amp;rsquo;ll be fine. That was acceptable to them. That was not acceptable to everybody: some people can&amp;rsquo;t be down for even a minute. So what I find a lot of times in these cases where you have some of these databases that aren&amp;rsquo;t as consistent as they lead on to be. People never in practice really run into them anyway because they are just not that big. Now, when you start talking about dozens of nodes or hundreds of nodes, that becomes a different case: failure is no longer an edge case. Failure is just common because if you think about the fact that if you have some small percentage, say even 1% chance that one of your nodes goes down and you have 100 nodes, there&amp;rsquo;s pretty good odds that one of those nodes is going to be down at any given time. So different systems, like Riak, is designed with that sort of high availability in mind. Now of course, what it gives up is consistency. It&amp;rsquo;s an &lt;a href="http://en.wikipedia.org/wiki/Eventual_consistency"&gt;eventually consistent&lt;/a&gt; system but it&amp;rsquo;s not a fully consistent system.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: OK. When you talk about availability and consistency, it seems like most databases will optimize for one of them. Is it like a continuum between the two?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: It&amp;rsquo;s very much a continuum and it&amp;rsquo;s not just a continuum between consistency and availability for design. In some cases, it&amp;rsquo;s how you configure your network or how you configure your servers. HBase, for example, you can make it either a consistent or available system. Something like Riak, in theory, could be written in such a way that you could have a fully consistent but not available system. &lt;a href="http://cassandra.apache.org/"&gt;Cassadra&lt;/a&gt; could be possibly be written that way too. The reason it&amp;rsquo;s not done that way is because people just don&amp;rsquo;t want it. We kind of have different customers. People use different databases for different reasons generally speaking, and to answer your question, they do tend to lean one way or the other. But whether they succeed is kind of a different question.&lt;/p&gt;

&lt;h4&gt;Part 2: Relational Databases&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: OK. I think this is a good time for us to dive into different genres of databases and see where they fall into this theorem and also what are the trade-offs that they made. Or in other words, when we pick those databases, why do you want to choose one of the databases? We&amp;rsquo;ll start with relational database cause that&amp;rsquo;s been around since forever. Where do you think relational databases fall into this CAP theorem?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Well, the CAP theorem only applies to distributed systems generally. It&amp;rsquo;s one of those thing that technically applies to non-distributed systems because if you give up partition-tolerance, you&amp;rsquo;ll have consistency and availability, but who cares? At that point, it&amp;rsquo;s like why are you even discussing an inherent problem of distributed systems in a non-distributed sense.
We can talk about Postgres for example. In any non-distributed systems, you have &lt;a href="http://en.wikipedia.org/wiki/ACID"&gt;ACID&lt;/a&gt; compliance. It&amp;rsquo;s Atomic, Consistent (completely different meaning than the CAP theorem of consistent by the way, which makes it very confusing to talk about), Isolated and Durable. These are what you want out of a transaction. It either succeeds or it doesn&amp;rsquo;t and entirely linear isolability is another term for it. Now, when you distribute them. This is what people don&amp;rsquo;t necessarily think about. If you have a backup of your relational database (which you should), you have effectively created a distributed system unwittingly and unknowingly. If you&amp;rsquo;ve ever had a relational database that has a backup and then your primary database crashes, you have to load from the backup and you&amp;rsquo;ve lost data. You have effectively lost consistency in the CAP theory sense. You&amp;rsquo;ve also lost availability because you were down for a while when you were trying to update. I&amp;rsquo;m not sure if that technically counts as being unavailable because your entire system is down then so there&amp;rsquo;s nothing up to even answer requests. There is another case, when people have relational databases and they don&amp;rsquo;t think about the CAP theorem does apply here, is cache: if you throw &lt;a href="http://memcached.org/"&gt;Memcached&lt;/a&gt; in the front of your relational database to more quickly answer requests, you again run into the CAP theorem: you have a consistency problem. Cache expiry is an eventually consistent issue. It&amp;rsquo;s a tough thing to avoid. Simply claiming that I have one big server and I don&amp;rsquo;t have to worry about these issues is completely missing the point. That&amp;rsquo;s of course still assuming only one server (but you can distribute relational databases, of course master/slave applications really come and set up). Again, this is one of those cases where you&amp;rsquo;re making some sort of consistency-availability trade-off. Very often it&amp;rsquo;s still eventually consistent. You can lock and say okay we want full consistency but now you have lost your availability. When I say lock, I mean lock across the network, not just lock within a single database because that&amp;rsquo;s effectively what you need: you need some sort of lock for full consistency. You need a consensus between your nodes. Usually what you&amp;rsquo;re giving up at that time is latency. You&amp;rsquo;re increasing your latency because you have to wait for all of these responses to happen.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: But latency is not part of the CAP trade-off.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: It is not. This is actually something that has been pointed out several times. &lt;a href="http://www.cs.berkeley.edu/~brewer/"&gt;Eric Brewer&lt;/a&gt; has mentioned this fact as well. Like I said before about PNUTS for example, they gave up consistency and availability for lower latency.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: You talked about master/slave and replication type of scenario. What about sharding relational database? I know it&amp;rsquo;s kind of &amp;hellip; You can also do that, but it comes with trade-off.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: It does come with trade-off. When people talk about distributed, that&amp;rsquo;s sort of a catch-all term for just having multiple computers. But when you&amp;rsquo;re talking about databases, there&amp;rsquo;s generally only two reasons you distribute: either you&amp;rsquo;re looking to increase availability by just being up more often and being safe if a node crashes (redundancy) or if you&amp;rsquo;re looking to expand resources so rather than just having one DB server, you horizontally scale. When you split one table to live on multiple servers, that&amp;rsquo;s sharding, that&amp;rsquo;s expanding the resources, whether it&amp;rsquo;s disk or CPU or RAM or whatever. You&amp;rsquo;re expanding the resources horizontally across multiple servers. Although that&amp;rsquo;s a good thing, unfortunately you&amp;rsquo;ve introduced an element of danger now because remember when I mentioned earlier that the more servers you add, the odds of any one of those going down remains the same so for each server, out of the entire group, it&amp;rsquo;s a high chance that at least one of them will be down. If you have 1000 nodes, one of them will probably go down. But the problem is, if you only have one copy, you have corrupted your data because say you&amp;rsquo;ve divided your table across 10 different servers and one of them goes down, you&amp;rsquo;ve lost 1/10 of your data. So you deal with that by also replicating and that&amp;rsquo;s the redundancy; that&amp;rsquo;s the safety part. But also, it&amp;rsquo;s good for reads as well: you can read from multiple servers so the resource requirements of any individual one has gone down because presumably you are dividing your reigns across all of these redundant servers as well. That of course introduces the problems of having to choose between consistency and availability though because once you&amp;rsquo;ve replicated a value to multiple servers, you&amp;rsquo;ll have to keep them all in sync: you&amp;rsquo;ll have to reach consensus. But reaching consensus is a very difficult thing and a lot of times what you pay in is latency. A quick comment, I keep throwing this word consensus around. The idea of consensus is in two parts: consensus is safely and liveness. Safety is the promise that nothing bad will happen that liveness is the promise that something good will eventually happen. There&amp;rsquo;s an old paper from the 80s called the &lt;a href="http://www.cs.yale.edu/homes/arvind/cs425/doc/fischer.pdf"&gt;FLP Impossibility Proof&lt;/a&gt; that shows you can&amp;rsquo;t actually guarantee both full safety and full liveness in a distributed system. Before this, people just threw out &lt;a href="http://en.wikipedia.org/wiki/Two-phase_commit_protocol"&gt;two-phase commit&lt;/a&gt;, thinking that it will solve their consensus problems. But if a network partition occurs, again as I said partition is the crux of all distributed system problems, you can lose liveness and actually you can even lose safety. So then they created &lt;a href="http://en.wikipedia.org/wiki/Three-phase_commit_protocol"&gt;three-phase commit&lt;/a&gt;. It has better liveness guarantees but it&amp;rsquo;s still potentially unsafe in the face of network partition. That&amp;rsquo;s why, maybe it&amp;rsquo;s been 10 years or more, &lt;a href="http://en.wikipedia.org/wiki/Leslie_Lamport"&gt;Leslie Lamport&lt;/a&gt; created a consensus system algorithm called &lt;a href="http://en.wikipedia.org/wiki/Paxos_algorithm"&gt;Paxos&lt;/a&gt; and it&amp;rsquo;s very powerful and it&amp;rsquo;s very flexible and it&amp;rsquo;s also very, very complex. There are very few good implementations out there. The importance of these consensus algorithms are unless you&amp;rsquo;re routing all of your traffic through one main master server, you can&amp;rsquo;t really have consistency in your distributed system, not in the way that we want liveness in terms of availability. What we live with is eventual consistency, which itself is a liveness (in terms of availability) property. &lt;a href="http://www.bailis.org/"&gt;Peter Bailis&lt;/a&gt; came up with this concept called &lt;a href="http://pbs.cs.berkeley.edu/"&gt;PBS (Probabilistically Bounded Staleness)&lt;/a&gt; and the point of it is to answer two questions about eventual consistency: first question is how eventual is eventual consistency and the second one is how consistent is eventual consistency. Again this is important because, if you&amp;rsquo;ve noticed, the very first word in there is probabilistically: what&amp;rsquo;s the probability of you values being stale because that&amp;rsquo;s really what it comes down to in most of these distributed systems. It&amp;rsquo;s when you have an eventually consistent system, you&amp;rsquo;re talking about probabilities now. This just cuts right through the heart of distributed databases because you want to be as consistent as possible but you also want to be as available and with the lowest latency, and to get all of those things is just not in the cards: you&amp;rsquo;re giving up something at some point. So the best thing to do is just figure out what exactly it is you need from a business case and make a decision that way.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: When we do get to the specific parts, we&amp;rsquo;ll ask you to give us some examples of use cases on how to choose. So we&amp;rsquo;re still on relational database?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Oh yes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: I kind of want to ask the question of open-source database like &lt;a href="http://www.mysql.com/"&gt;MySQL&lt;/a&gt; and Postgres v.s. proprietary database such as &lt;a href="http://www.oracle.com/us/products/database/overview/index.html"&gt;Oracle&lt;/a&gt;, &lt;a href="http://www-01.ibm.com/software/data/db2/"&gt;DB2&lt;/a&gt;, &lt;a href="http://www.sybase.ca/products/databasemanagement"&gt;Sybase&lt;/a&gt; and so on. Is anybody there still using non-open-source databases? Is there a reason not to use open-source databases?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Not really. That&amp;rsquo;s about as boring and straight-forward as it can be: there&amp;rsquo;s no good reason not to use an open-source database. There once was but these aren&amp;rsquo;t true anymore. The fear of vendor lock-in is pretty well abated. It&amp;rsquo;s not problem in the way that it was. If you use MySQL and you don&amp;rsquo;t like it, try Postgres. If you don&amp;rsquo;t like that, try &lt;a href="http://voltdb.com/"&gt;Volt&lt;/a&gt;. There are so many relational databases out there that are open-source. You may as well just go for it and use them. I have been in charge of three conversions to MySQL or Postgres from a proprietary database. Two of them were Oracle and one was &lt;a href="http://www.microsoft.com/en-us/server-cloud/products/sql-server/"&gt;SQL server&lt;/a&gt;. In every case, we saw a significant improvement in performance largely around just because as we were doing this port we&amp;rsquo;ve been able to refactor everything but the point being that it was successful, it worked well and it was cheap. There&amp;rsquo;s often a fear of using open-source systems as who&amp;rsquo;s going to support this. I can&amp;rsquo;t think of a single open-source database that doesn&amp;rsquo;t have a company backing it right now. They all do. Maybe Couch doesn&amp;rsquo;t, I don&amp;rsquo;t know. There&amp;rsquo;s &lt;a href="http://www.couchbase.com/"&gt;Couchbase&lt;/a&gt; but that&amp;rsquo;s kind of its own database. They all do. There&amp;rsquo;s always somebody to call if you have problems. They all have books; they all have communities. You can always just email &lt;a href="http://stackoverflow.com/"&gt;Stack Overflow&lt;/a&gt;. The reason I bring that up is the fear of using an open-source database I find is generally the fear of the lack of support like who do I call if something goes wrong. However, I&amp;rsquo;ve had problems with industrial commercial support as well. If it means that much to you to have someone in the blind to be paid $500,000 a year in licensing fee then you have more money to throw around than I do because I would rather just hire five engineers for that price or unless if you&amp;rsquo;re in Silicon Valley then two engineers and just have them on the job.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: So out of the open-source relational databases, I know you have experience with Postgres so that&amp;rsquo;s sort of front-runner nowadays.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: That&amp;rsquo;s my front-runner. I&amp;rsquo;ll be honest, in the past three or four years, I haven&amp;rsquo;t really been involved much in the relational database world. I pretty much spent my lifetime (10,000 hours) in front of my computer on relational databases and it&amp;rsquo;s not something I&amp;rsquo;m interested in going back to. I still think they&amp;rsquo;re amazing and I still think relational databases will solve the majority of people&amp;rsquo;s problems. I think that far too many people rush to alternatives for no good reason. But I definitely still throw out Postgres because I just prefer the design and now again this is my entire biased opinion. It&amp;rsquo;s the one that I&amp;rsquo;m the most comfortable with. It&amp;rsquo;s the one that most of my knowledge of the internals peaked around 2004 and at the time its internals were far cleaner and much more flexible than something like MySQL at the time: you could actually write your own indexes rather painlessly. They have just implemented it so you could write your own B-tree style indexes with even less trouble than just flexible scripting almost. I just enjoyed the flexibility and the community.&lt;/p&gt;

&lt;h4&gt;Part 3: NoSQL databases&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Let&amp;rsquo;s move away from relational databases. There&amp;rsquo;s this &lt;a href="http://en.wikipedia.org/wiki/NoSQL"&gt;NoSQL&lt;/a&gt; basket for all of the non-relational ones. My first question is why did NoSQL emerge in the last 10 years? What has changed to give birth to this set of databases?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: My theory is that there are really two reasons why NoSQL emerged: one is just the fact that as more and more people have got on the web, more and more people have constantly connected devices, we&amp;rsquo;re just collecting more data and that amount of data was something that was never envisioned for relational databases. Relational databases can handle lots of data. They can go into TB range but it&amp;rsquo;s one thing to be able to collect TBs of data and it&amp;rsquo;s another thing to be able to respond quickly to requests once you&amp;rsquo;ve collected that data. So one is just the amount of data and two is that over the years, relational databases have been very specifically tuned for business intelligence: for doing analytics and data warehousing and things like that. Because they weren&amp;rsquo;t dealing with such massive data sets most of the time and if they were it was some sort of just data that you could just put in the background and just archive it and then build a data warehouse star pattern (schema). I think those two reasons, more than any other, are responsible for companies having to effectively go along. The first few NoSQL databases that popped up were Amazon and Google because databases like Oracle just couldn&amp;rsquo;t keep up. They needed something different. As more and more people started having these same problems, at the same time, virtualization was getting easier and cheaper to scale out horizontally. This is something that relational databases historically have been very bad at so they took advantage of all these virtualized systems and were able to scale out. So these databases were designed to do that. HBase, &lt;a href="http://en.wikipedia.org/wiki/Dynamo_(storage_system)%E2%80%8E"&gt;Dynamo&lt;/a&gt; were designed to do this. That&amp;rsquo;s sort of my pet theory on why NoSQL has emerged recently. But you&amp;rsquo;re starting to see in some cases relational (databases) try to catch up. I&amp;rsquo;ve mentioned VoltDB. It&amp;rsquo;s made to be a horizontally-scalable database. I don&amp;rsquo;t know anyone that uses it. It may well be great. &lt;a href="https://voltdb.com/about/leadership/michael-stonebraker/"&gt;Stonebraker&lt;/a&gt; is brilliant so I would definitely never bet against him. But I don&amp;rsquo;t know if people have just decided that they don&amp;rsquo;t need all of the relational trappings or if they believe that they can&amp;rsquo;t have them. But for some reason, people have been flocking to NoSQL database world.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dingding&lt;/strong&gt;: So, you can build a distributed relational database with distributed nodes so you can have hundred of Postgres nodes and just build an upper layer to make it distributed. What&amp;rsquo;s your opinion of that against a NoSQL solution?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: It&amp;rsquo;s interesting. If you think of that architecture and you work with the architecture of something like Mongo, you&amp;rsquo;ll see a lot of similarities where you have a mater node that replicates and then you&amp;rsquo;ll have your Mongo server that accesses a router and your configuration that track where different keys go, they&amp;rsquo;ll feed Mongo to decide this shard goes to this replica set. Very similar to the way you would do manually in a relational database. But again your problem comes down to the CAP theorem. It comes down to the fact that you still have to make a consistency-availability trade-off. You can use something like Prosgres but you don&amp;rsquo;t really get all the benefits anymore. You can&amp;rsquo;t really easily or realistically join, for example, across a network. Really, the power of relational databases come down to the fact that you can normalize all of your data structures and if it&amp;rsquo;s normalized, you can query it in pretty much any way you want and more specifically joining. You can join values and create new table types and relations that you get as response. You have effectively lost the ability to do both of those once you start distributing your relational database unless you&amp;rsquo;re just doing straight-up replication. I know people do this a lot but sometimes I get the feeling they do it just because they just don&amp;rsquo;t know any better. If you&amp;rsquo;re doing that, I would recommend just trying something else. Just try a system that was designed to be distributed from the ground up and not shoehorn a system that was not designed to be distributed into becoming a distrusted system. The important thing to note about all of the databases that we&amp;rsquo;ve mentioned so far, with enough code, you can make them all do anything if you want to hack enough around it. The question is how much effort you really want to put into designing your own kind of database ecosystem, which effectively what you&amp;rsquo;re doing. You also have to think about operational costs. Yes, you can create these sort of custom clusters of relational database to do the things you want but now you effective have to worry about is this a master node or is this a secondary or is this a configuration or is this a router. You&amp;rsquo;ve sort of offloaded your development costs and put it squarely on your operational costs. This is something developers don&amp;rsquo;t often think about when they are coding: coding is the cheapest and fastest phase of your process. The more expensive and much long part of it is operations. Assuming you&amp;rsquo;re successful as a developer, someone is going to be running and maintaining that code for years. If you design it in such a way that is complex to scale and maintain, you&amp;rsquo;ve effectively just given some future person a whole lot of work. If you&amp;rsquo;re not distributing, just use relational database. They&amp;rsquo;re easy and they have a ton of research behind them for years. SQL is an amazing language. It&amp;rsquo;s the most successful language ever. Think of any language that&amp;rsquo;s been around that long. You&amp;rsquo;re talking about C and SQL in some form, obviously not in the SQL specification. That&amp;rsquo;s much older than 40 years but the whole relational concept. If you&amp;rsquo;re distributing, go after a NoSQL solution.&lt;/p&gt;

&lt;h4&gt;Part 4: Document Databases and Column Databaes&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Talking about NoSQL, a lot of people equate them to document databases. That seems to be most popular one nowadays. So why don&amp;rsquo;t we start with document databases? What are the trade-offs and maybe in the CAP theorem context?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Again, I wouldn&amp;rsquo;t necessarily want to frame this as a CAP theorem thing because there&amp;rsquo;s no reason we couldn&amp;rsquo;t design a document database that&amp;rsquo;s a consistent v.s available. If you look at Mongo for example. It&amp;rsquo;s designed to be a consistent database. One thing I will say is that &lt;a href="http://aphyr.com/"&gt;Kyle Kingsbury&lt;/a&gt; recently wrote &lt;a href="http://aphyr.com/tags/jepsen"&gt;a series of blog posts&lt;/a&gt; about many of the databases about many of the databases that we&amp;rsquo;re talking about here where he stress-tests and he creates artificial partitions and queries them in different scenarios and looks at the failure rates. What he uncovered is that a lot of the claims that are made by some of these implementations don&amp;rsquo;t necessarily hold up in a very tough scenario. Again, fairness, being what it is, in the real world, these may not come up quite as often. He really hammed it. One of the losers in his initial attempt was the default settings that come with Riak which was kind of painful for some of us at Basho to have to see but there are settings you can make it better and most of the databases did. There were configurations that you could follow. I will try to find that link and send it to you because they&amp;rsquo;re definitely a fascinating read. As far as document datastores, the two that I covered in my book are Mongo and Couch. Mongo, for many people, is synonymous with NoSQL: if you say NoSQL, it&amp;rsquo;s the first thing that pops into their head. There&amp;rsquo;s a lot of reasons for this, one of which is it&amp;rsquo;s the first popular one to come out and it still remains the most popular as far as just sheer number of users. Mongo, in the CAP theorem senses, is slated to be consistent and of course that means it&amp;rsquo;s beat is availability, in the technical sense, if there&amp;rsquo;s a partition. Although that used to be a selling point, Mongo actually is from the middle of the word humongous because it was supposed to deal with humongous data sets. By design it&amp;rsquo;s very similar to what you would do manually if you took a relational database and wanted to create a master/slave setup yourself and shard keys and things like this. Part of the popularity is just the fact that it&amp;rsquo;s really easy to use if you are used to a relational system. It comes with a very simple query language where you just put values in. (When) I say document, I don&amp;rsquo;t mean a document like a PDF or Word file or anything like that. A document, in this case, is just JSON and is keyed by an id. Other than that, you can query by any value. This is actually really important if you are designing something and you&amp;rsquo;re not entirely sure where you&amp;rsquo;re going with it because unlike a relational database where you have a very structured schema and you have to say I&amp;rsquo;m going to have a person table and a person is going to have a first name and a last name then later on you decide oh I want to add middle name too. Now you&amp;rsquo;ve got to create a new column called middle name and you&amp;rsquo;ve got to actually tell the database what that schema is. In a document data store, like Mongo and Couch, you don&amp;rsquo;t actually have to tell it anything in advance: you just give it a key-value, just like any JSON, &lt;code&gt;first:fist_name&lt;/code&gt; and &lt;code&gt;last:last_name&lt;/code&gt;. And then if you just decide you want to start adding middle name or initial, you just start adding middle name fields. You don&amp;rsquo;t have to migrate your old data in any way. This obviously has a cost on retrieval: it&amp;rsquo;s easy to put values in but when you pull values out, you code has to deal with the fact that there might be nothing there. So over time, your code could get crufty. But if you&amp;rsquo;re going very fast, this is a trade-off that people, especially developers, don&amp;rsquo;t mind paying. Couch has the same benefit. The difference being though the way you query Couch is you actually write MapReduce and that MapReduce is a view over your data in some way. For example, if you want to be able to query by last names, you would write a MapReduce that would extract last names out of your values and any time you would do a search, you search for values that have been extracted by this MapReduce view. Mongo doesn&amp;rsquo;t require you to do that: for its query mechanism, it&amp;rsquo;s much more like a relational database where you&amp;rsquo;ll just say give me very last name that match this name or give me everything between this last name range. It feels much more like a relational database. That said, if not a relational database, you don&amp;rsquo;t normalize it. It&amp;rsquo;s almost inherently denormalized. Since it&amp;rsquo;s JSON, you can nest values: your person could contain an array of pets. So in relational databases you might have to a separate pets table and then join it with a person. In this case, your person will just contain pets. That makes it really easy to build and it makes it really easy to put data in. It makes it slightly more difficult to get data out because if you just for example want the names of everyone&amp;rsquo;s pets, you&amp;rsquo;ll have to do a more complex query than you would in a relational database where you just say &lt;code&gt;select * from pets&lt;/code&gt;. You would have to say, get all the users, find all the pets, extract those names and then give them to me as a list or as a collection. That adds a little more complexity when you write your queries. This is something you&amp;rsquo;ll find with most NoSQL databases: it&amp;rsquo;s much easier to get data in than it is to get data out. And this is part of the reason in my opinion you&amp;rsquo;re seeing popularity of other third-party analytics tools like &lt;a href="http://hadoop.apache.org/"&gt;Hadoop&lt;/a&gt;, which is like a MapReduce engine where it can perform queries across the system predicated on the idea that when you have TBs of data spread across multiple servers. It&amp;rsquo;s cheaper to take the algorithm and just send it to the servers, let them compute the value and then give it to you than what you would do in a relational side where you stream data and then compute it because it doesn&amp;rsquo;t matter because it&amp;rsquo;s all on the same box anyway.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: So it&amp;rsquo;s easier to ship your queries or the algorithm themselves to the data because you have a distributed system than to getting pieces of data from each place and try to join them together or get a result.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Yes, it&amp;rsquo;s just the matter of reducing the amount of data going over the wire. When you&amp;rsquo;re dealing with big data, you very often have to invert your way of thinking and this is one of those cases where you invert the order of operations you are normally used to doing. One of those inversions I mentioned before where very often you don&amp;rsquo;t necessarily think about how you&amp;rsquo;re querying the data. You just put it in there and you worry about querying it later. That obviously has its own cost. You&amp;rsquo;re going to be paying these costs anyway. In a relational database, you just pay them in a very different way: you pay them upfront, in the design phase. While you&amp;rsquo;re sitting down designing something, how many times have you done an application that you&amp;rsquo;re using a relational database and you start with a whiteboard and you start drawing tables and saying okay we&amp;rsquo;re going to want to do this and this is what our scheme is going to look like and you start coding and say oh crap, I need a different table or I need join tables to sit in-between these because the join needs to actually have another value hanging off of it, so I need to create a whole new table. These design decisions are very trivial when you&amp;rsquo;re dealing with a lot of these NoSQL solutions but the querying is more difficult.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Yeah, I guess the compliment with relation databases was querying is really powerful, really super easy. Whereas when you would start to add data, then you start to face the CAP theorems. I still want to talk a little bit more about Mongo because that seems to be the popular one. We talked about availability and some of the trade-offs but from a data modelling point of view, if you just compare relational database with a Mongo data, I feel like Mongo is a very opinionated way. It&amp;rsquo;s like if you know exactly you want to traverse the data, then Mongo is perfect. In your example, a person and cat. Maybe cat has toys. If you know you always go from person to cat to get toys, you never would just aggregate some toys that way, then it&amp;rsquo;s perfect. You can always go that way. But you&amp;rsquo;re losing the flexibility. You may not anticipate you do need to do another scan.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Yes. The flexibility you lose is the query flexibility of a relational database. That said, no database has the query flexibility of a relational database. The relational database designed SQL is a query language. It&amp;rsquo;s a declarative language. It&amp;rsquo;s structured. But that&amp;rsquo;s exactly its strength and largely that&amp;rsquo;s its biggest strength. And relational databases are the only ones where you have a somewhat structured schema. Column-oriented databases like HBase, you define your schema upfront. Cassadra is another: it&amp;rsquo;s topologically Dynamo-based like Riak is but its data structure is column-oriented like HBase is where you define what your column families are. They do have a little more flexibility than a relational database. The problem for relational databases is you put one value per row for example whereas in a column-oriented data store you can have as many individual discrete values as you want without adding rows: you&amp;rsquo;re just adding that value because data is stored in columns rather than rows. A simple example would be a wiki where the key might be the title of the wiki page and you might have multiple revisions. In a relational database, unless you denormalized it, if you just said okay my page table will have one column for the title and one column for the contents of the page. What you&amp;rsquo;ll find is the title never changes, so you&amp;rsquo;ll just be replicating that a lot and the contents of the page change quite often. Whereas in a column data store, you would have just one column family page and the title would never change. That would be one column and another column would be the contents of the page and it would change. When you do a query, it&amp;rsquo;s a row but it&amp;rsquo;s almost like a pseudo row. You&amp;rsquo;re just saying okay give me the most recent title and the most recent page contents. You actually can get a lot out of this: you can give them a time to live, which is very nice. There&amp;rsquo;s a reason that Facebook&amp;rsquo;s messaging system runs on HBase. The ability for messages to have a time to live is something I presume they are able to leverage and also it scales up crazy.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Right. I guess if you do this on a SQL database, it&amp;rsquo;ll be non-trivial or you&amp;rsquo;ll have to write a lot of code to run it like that.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Yes, or you&amp;rsquo;ll have to have some sort of custom extension. I wouldn&amp;rsquo;t be surprise if something like Postgres had a time to live extension or a timestamp. Generally what you&amp;rsquo;ll do is you&amp;rsquo;ll just timestamp a value and then as part of query you&amp;rsquo;ll just say give me this range and then maybe manually delete everything that&amp;rsquo;s outside of that range. But that would be one trivial way of doing it but it&amp;rsquo;s nice to have these things built-in, that&amp;rsquo;s for sure. Again, like I said before, most of these databases, with enough code, you can make them do them to anything but how much code do you want to write?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dingding&lt;/strong&gt;: When we talked about document DB, you mentioned some column DB like HBase and Cassadra. Document DB to me is similar to column DB but with few limitation and more improvement. So what&amp;rsquo;s your opinion with these two and the difference between them?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Actually a document DB is much closer to a key-value store in this way because Mongo or Couch, whether its queries or views, by default is not actually indexing the values. The only thing that&amp;rsquo;s indexed is the id, which is just a key look-up. But if you query against a column that&amp;rsquo;s not indexed, it&amp;rsquo;s just a full table scan. The same is true with Mango and Couch. The same is not true with something like HBase where these are sparsely ordered. You&amp;rsquo;re actually always scanning effectively. I guess you can do key-value look-ups as well but generally you scan ranges of values. To index, you&amp;rsquo;ll effectively index manually. Again, depending on how much code you want to write, you can index with a key-value store as well. If you have Redis for example, which is a key-value store and you have a deeply nested value and you want to be able to query by certain values, you can just create another key type and say okay I&amp;rsquo;m going to be a quick-up and point to the, for example, say you have a &lt;code&gt;person:social_security_number&lt;/code&gt; and that&amp;rsquo;ll contain all of the person data that we talked about earlier with our Mongo example: searched by last name. You can just create a key like &lt;code&gt;last:last_name&lt;/code&gt; and then it can point to the correct &lt;code&gt;person:social_security_number&lt;/code&gt; and then it&amp;rsquo;s just a look-up. You can do this with a key-value store. In relational databases, obviously to do it effectively, you need some sort of ability to scan. So you could effective write your B-tree if you can&amp;rsquo;t scan. It depends on how much code you want to write but I would say generally speaking, I actually find much more similararity between a key-value store and a document data store than I would in a column-oriented data store and a document data store.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: I would say that as well. I feel like one way you look at document databases, they&amp;rsquo;re also key-value stores but the value can be nested.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Riak, for example, all values are opaque, meaning it doesn&amp;rsquo;t care what the value is so you can actually put JSON as a value inside of Riak. It has a secondary indexing feature so if you want to index against some of those values, you just make it index and you query against that index. That would make it closer to Mongo in that respect as far as querybility. Or if you want to use MapReduce, you can do that too, which case it&amp;rsquo;ll be something more close to Couch although Couch is considerably more efficient on the way that it builds its views cause it pre-builds them and just keeps them updated using partial MapReduce as you make updates. You&amp;rsquo;re absolutely right. There&amp;rsquo;s much more similarity than differences in that respect.&lt;/p&gt;

&lt;h4&gt;Part 5: Key-value Stores&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: We talked about document databases and column databases already and you mentioned Mongo, Couch, HBase and Cassandra. Let&amp;rsquo;s move to key-value stores. We already touched on Redis already. Maybe you can talk about Redis and Riak in comparison? Those two key-value stores. What are the characteristics of each and so on?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Sure. The reason I added two key-value stores in this book was as an example that the network topology can be very different or the use cases can be very different for a similar modelling style. So key-value store is effectively like a hash map or a dictionary or an object (if you&amp;rsquo;re a JavaScript person) where you just have some key, you store a value with that key and if you want that value later, all you require is that key to get the value back out. This is really useful for many things, one of which is caching. That&amp;rsquo;s where Redis excels. Redis lives entirely in main memory so it&amp;rsquo;s very, very fast. It&amp;rsquo;s clever in the fact that it&amp;rsquo;s sort of designed for those caching use cases where you want some sort of intermediary between the way your data might live on a different back-end, whether it&amp;rsquo;s a relational dabase or CouchDB or whatever and the way you might want to use it. It does this by being able to store values that aren&amp;rsquo;t opaque in the way that they are in Memcached. In Memcached, all values are strings. If you do any encoding, it&amp;rsquo;s entirely up to you. You can turn them into lists, you can turn them into objects, hash tables, whatever but you just have to serialize it as a string, store it as a string, pull it back out, de-serialize it and do whatever. Redis does a lot of this work for you. It supports limited data structures like lists, sets. It can do key range searches by wildcard. It also got some other built-in things. &lt;a href="http://redis.io/topics/pubsub"&gt;Pub/Sub&lt;/a&gt; is very popular. It can do interesting things on the data strictures. For example, you can take the value of two keys that might be set and do a set union on them or a set intersection. This is useful in a lot of ways. For example, going back to the person example, you each have pets and toys. Say we each have our own pet and they&amp;rsquo;ll be keyed in some way and they&amp;rsquo;ll contain a set of all of the toys that they play with. My cat might play with a box and a ball of string and your cat might play with a ball of string and feather and we can do a set intersection and say what do our cats agree on and they&amp;rsquo;ll say the set intersection of these two sets are a ball of string. It&amp;rsquo;s the common value. This is something that&amp;rsquo;s fairly unique to Redis in the world of key-value data stores. They are also very common operations when you want cache values. You have a lot more flexibility than you would. Something like Memcached would require you to write code. They would pull the set from my pet, the set from your pet, convert them and then perform the intersection on the client side. Very, very powerful. (It&amp;rsquo;s) part of the reason why its adaption is so high for these use cases. Now, one thing it&amp;rsquo;s not great at is it&amp;rsquo;s not durable. It has durability options but that&amp;rsquo;s really just in the case where a node might crash, it&amp;rsquo;s fast to warm up. As far as being distributed, it&amp;rsquo;s not to the level of many other distributed systems.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: We talked Redis in the caching context. It&amp;rsquo;s mostly read. I&amp;rsquo;ve seen some people that use Redis as an intermediary to their database so instead of all the operation touching database they can just put in memory and it&amp;rsquo;s fast.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: It&amp;rsquo;s actually faster to write to Redis than it is to read from it. I just experimented once before and I was able to get 100,000 operations writing and 80,000 reading. I don&amp;rsquo;t remember what the time frame was. Maybe a second. Part of it is because it has to convert the value into something when it reads. Actually, I often recommend this a lot. It&amp;rsquo;s for data transformation using Redis as an intermediary. I actually did a sample project: in the last chapter of the Seven Databases book I used Redis as an intermediate data transform from a tab-separated value into a document that&amp;rsquo;s suitable to be stored in Couch. And it&amp;rsquo;s because it&amp;rsquo;s much faster to find duplicates in a Redis than it was to try and do a write to Couch that may have conflicted version-wise. This is a multi-threaded application to go faster. If two writes are going at the same time then Couch would reject the attempt at one of them so it has to go back to the application and say okay Couch rejected this and it has to read Couch again to get the newest revision number and then attempt to write again and sometimes that round-trip will push it back again because another write has succeeded in the interim so you can fill up your write effort rather quickly. So I 100% agree with that as well. It&amp;rsquo;s not just caching. That&amp;rsquo;s just the most common use case. Data transform is fantastic for it. The other key-value store that I wrote about is Riak which we should definitely talk about. Riak is actually designed to be a highly available system. It&amp;rsquo;s made for the case where you can&amp;rsquo;t be down for any amount of time. We&amp;rsquo;ve actually have customers that have had 100% up-time as crazy as that might seem. &lt;a href="http://www.comcast.com/"&gt;Comcast&lt;/a&gt; mostly gave a &lt;a href="http://vimeo.com/54270121"&gt;talk&lt;/a&gt;. They said since they&amp;rsquo;ve installed Riak, for the past three years, that system has been up 100%, which is unheard of in the database world. Part of the reason is because of the way it&amp;rsquo;s designed: it has built-in sharding and replication. You can lose many servers and still be up. One of our customers had 30 nodes, and if I recall correctly, 13 of the 30 nodes went down and they didn&amp;rsquo;t realize it. It took them like a couple days to notice a lot of the servers were down and they spin them back up and everything was fine. This is really Riak sweet spot. It&amp;rsquo;s not made to necessarily be the fastest store or the largest scale. It&amp;rsquo;s really made to just be up all the time and you could survive a nuclear blast and Riak will be fine as long as you&amp;rsquo;ve got &lt;a href="http://docs.basho.com/riakee/latest/cookbooks/Multi-Data-Center-Replication-Architecture/"&gt;Multi-Datacenter Replication&lt;/a&gt; and you&amp;rsquo;ve replicated all your values in multiple datacenters.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: So does the replications happen automatically?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Well, Multi-Datacenter Replication is actually the one thing that we charge for. The single datacenter replication is built-in. When you write a value to Riak, it will by default replicate to three nodes. This is tunable, you can set its value to whatever you want. We usually recommend 3: it&amp;rsquo;s usually sufficient for most cases. That means at least 2/3 of that value&amp;rsquo;s nodes could go down and you still have data available. Then there&amp;rsquo;s Multi-Datacenter Replication which means that you have multiple datacenters that themselves replicate through each other to keep themselves in sync by various means. It&amp;rsquo;s very tunable. This is for a lot of reasons, either data locality: so you can have a cluster in the U.S and a cluster in China and you can have data local to your Chinese customers cause they can access it faster v.s other data that&amp;rsquo;s local to your U.S customers or you can have two datacenters and one is just used for backup or whatever other reasons people have for choosing to replicate at multiple datacenters.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: By the way, I&amp;rsquo;m just curious, are you aware of the companies using Riak in China?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: I&amp;rsquo;m not. Actually that&amp;rsquo;s definitely something I&amp;rsquo;m very interested in. If anyone&amp;rsquo;s interested in helping spread the word about Riak in China, I&amp;rsquo;d love to hear from them or if anybody that knows of any companies in China that are using Riak, I would love to hear from them. We are a company that was found in the U.S. All of our first customers are in the U.S, then we went to Europe and six months ago we opened an office in Japan so we&amp;rsquo;re slowly spreading internationally. Any way to speed up that trend would be amazing cause we have not really spread to South America as far as I know as well. We may be everywhere. I just haven&amp;rsquo;t heard about them.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Is Riak itself an open-source database?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Riak is 95% open-source. Riak itself is entirely open-source and &lt;a href="http://basho.com/riak-cloud-storage/"&gt;Riak CS&lt;/a&gt;, which is like sort of &lt;a href="http://aws.amazon.com/s3/"&gt;Amazon S3&lt;/a&gt;, object storage. You can run Riak CS where CS stands for Cloud Storage which acts like your own personal S3. It has an S3 interface so you can actually use all of your S3 code. There&amp;rsquo;s a lot of regulatory reasons or just financial reasons that people might want to run their own S3 system and that&amp;rsquo;s entirely free. The only thing we charge for is Multi-Datacenter Replication and of course if anybody wants to buy support. That&amp;rsquo;s true for Riak and that&amp;rsquo;s true for every other database I&amp;rsquo;ve mentioned. There&amp;rsquo;s all sorts of companies behind these databses: Mongo has 10gen; Postgres has a consortium of independent contractors; Neo4j has &lt;a href="http://www.neotechnology.com/"&gt;Neo Technology&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: I was just thinking because when it comes to China, a lot of things are big data and it&amp;rsquo;s typical that you walk into a bank and you have 10,000,000 customers or 100,000,000 customers very easily. Coming back to Riak, you talked about Riak automatically replicates the data records, does it hurt its consistency or how does it make that choice?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: As we&amp;rsquo;ve mentioned previously about the CAP theorem being kind of a spectrum: consistency and availability are in some ways tunable. It doesn&amp;rsquo;t have to be fixed. This comes back to what I&amp;rsquo;ve mentioned about Peter Bailiss and PBS (Probabilistically Bounded Staleness, how eventual is eventual consistency and how consistent is eventual consistency), you can tune your eventual consistency. You can tune your availability and your consistency and in some ways your latency as well is effectively this way. The way Riak does it is it has three values called N, R and W. N is the number of nodes you will replicate a value to eventually. By default, it&amp;rsquo;s 3. W is the number of nodes that will return a successful affirmative before you return back to the client and say yes this write woks so what happens is your write to one of the Riak notes will coordinate the replication. So if you set W to 2, what it&amp;rsquo;ll do is even though eventually all three nodes will have the value replicated that you want, it will only wait until two of them returned a success before it says the write is successful. R is the last one, which is the same thing but for reads. You&amp;rsquo;ll attempt to read from all three nodes but if you set R to 2, only two of them need to return a success for value to get a result. You&amp;rsquo;re not going to wait for all three. Now if you want to make a more consistent system, the consistency can be either write consistent or read consistent. So for example, say that I have my end value and I want to be certain that my write has been replicated to all three so I can set W to 3 and say don&amp;rsquo;t even return until every value has been replicated. At this point, you can be pretty certain that successive reads are going to contain that value but you&amp;rsquo;ve of course slowed down. You paid in latency and availability because if one of those three replicas is down, your write will fail because what you told it is I need all three to work. One of them is down, you only two up, it can fail. That&amp;rsquo;s what&amp;rsquo;s called the quorum. The quorum means if your R(Read) value + your W(Write) value &amp;gt; number of nodes, then you&amp;rsquo;re probably going to be consistent, assuming everything goes according to plan because there&amp;rsquo;s going to be an overlap. It&amp;rsquo;s an easy thought experiment. Say you have nodes A, B and C, and you write successfully to nodes A and C and you read successfully from nodes B and C, then even though only C has the most recent value, you&amp;rsquo;ve at least got the most recent value and you know this. There are details here. I&amp;rsquo;m not going to all of the problems why that&amp;rsquo;s not exactly truly consistent, not in the linearizable sense but it&amp;rsquo;s consistent enough for being a highly available system, which is the whole point. You can flip it over: if you want to write quickly but you don&amp;rsquo;t care to wait, you can set W to 1 and say just write to one node, I don&amp;rsquo;t care which one, and then return. Your latency would go down because you&amp;rsquo;re not waiting for all three replicas to return: whenever the fastest won the return race, then you&amp;rsquo;re just back and you say okay I won. Then when you do a read, if you want the most recent value, you can then set R to the number of nodes and you&amp;rsquo;re effectively reading from all of them cause you&amp;rsquo;re saying at least one of these is going to have the most recent write. But you&amp;rsquo;ve slowed down your read at that time and again you&amp;rsquo;ve paid in latency and if one of those nodes is down, you&amp;rsquo;ve paid in availability. I&amp;rsquo;m oversimplifying this because there actually is a little more detail to it than that: there&amp;rsquo;s durable writes; there&amp;rsquo;s primary writes, primary reads. Because Riak by default does something, and this is something Dynamo does as well called sloppy quorum where if a node you would normally write to or read from isn&amp;rsquo;t available, it will then go to the secondary node, which is the next from the list. It&amp;rsquo;s not a strict quorum in the fact that it would fail. It would actually try to do that right any way. And it would just elect another node to act as a temporary storage. This is like, if you&amp;rsquo;ve gone on vacation and while you&amp;rsquo;re on vacation, you have your neighbour collect your all your mails and then once you&amp;rsquo;ve come back from vacation, your neighbour hands you all your mail. In Riak, this is called the hinted handoff. So once the node has rejoined because it had crashed or because there was a network partion, all of that data gets given back to the primary node, the one that should had it all along. It&amp;rsquo;s tricks like this that allowed Riak to be highly available system. This is why you get these kinds of crazy up-times that you don&amp;rsquo;t necessarily get with all other databases that choose consistency over this kind of availability.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: I guess the use cases for Riak is if the business requirement is such that availability is paramount. No way this can be down, money is at stake or &amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Yes, and that&amp;rsquo;s generally the way I would pitch it: if being down costs you something, whether it&amp;rsquo;s money or users, if people would just get tired and leave. This is actually why Amazon designed Dynamo. So Riak is based off the Amazon Dynamo database design as is Cassandra topologically, whereas HBase is designed off Google &lt;a href="http://en.wikipedia.org/wiki/BigTable"&gt;BigTable&lt;/a&gt;. Amazon designed it in this way because they had done research that found that, they had it down to a dollar value, that was for every millisecond of latency, it actually costs this many dollars because people would just get fed up and leave because they do so many transactions so if you&amp;rsquo;re doing a lot of these transactions, you can&amp;rsquo;t have latency, you can&amp;rsquo;t be down. It&amp;rsquo;s interesting because EC2 and S3 famously go down like once a year and since half of the internet is built on EC2, everybody suffers these consequences and everybody freaks out but what&amp;rsquo;s interesting is: Amazon itself doesn&amp;rsquo;t go down if you ever noticed this. A lot of it is because of their internal architecture, not the one that they give everyone else but their own.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: So DynamoDB is hosted right? It&amp;rsquo;s Database as a Service where you can just spin up but Riak is a little bit different. It&amp;rsquo;s not hosted.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: I&amp;rsquo;m not entirely sold on what DynamoDB is for because my general feeling is if you require such extreme amount of up-time where you need to use something like Riak. Just completely handing that off to a third-party seems weird to me. Just giving someone else control over one thing, in exchange you get a lot of control over it. I think you can set your own R, W, N values but who cares; I mean you don&amp;rsquo;t own these servers anyways. If I were going to use a host solution because I didn&amp;rsquo;t care that much, I would just use a database that&amp;rsquo;s easier to use. There&amp;rsquo;s MongoHQ and &lt;a href="https://mongolab.com/welcome/"&gt;MongoLab&lt;/a&gt; if you want to do that; There&amp;rsquo;s &lt;a href="http://redistogo.com/"&gt;Redis To Go&lt;/a&gt; if you want to use hosted Redis; There&amp;rsquo;s a &lt;a href="https://www.heroku.com/postgres"&gt;Horoku Postgres&lt;/a&gt;. There&amp;rsquo;s a lot of other options for hosted databases. I&amp;rsquo;ll probably going to get flagged for saying that but I&amp;rsquo;m not telling you that you don&amp;rsquo;t use it. If you get a good use case, go ahead and use it, but it definitely wouldn&amp;rsquo;t be my first choice.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: One scenario of getting this kind of infrastructure is if your infrastructure is solely based on EC2 then that&amp;rsquo;s great; if you have infrastructure away not on Amazon&amp;rsquo;s cloud then you&amp;rsquo;ll have to pay extra latency to retrieve the data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: That&amp;rsquo;s true. Of course they designed it that way. They absolutely want you to use all of their infrastructure for everything and they&amp;rsquo;ve very much set it up in that way. There are outline cases: if you have a lot of money and you&amp;rsquo;re a huge customer you can use &lt;a href="https://aws.amazon.com/directconnect/"&gt;Amazon Direct Connect&lt;/a&gt; which costs like six grand a month or something and they&amp;rsquo;ll co-locate a fat pipe for relatively low latency. You can do all of these things but if you&amp;rsquo;re to that level, why are you using EC2 anyway? Why are you letting them host anything? There&amp;rsquo;s a lot of customers that love it and I can&amp;rsquo;t speak too poorly because people are using it successfully; Maybe I&amp;rsquo;m a little more paranoid than everyone else. We haven&amp;rsquo;t covered Neo4j at all.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: It&amp;rsquo;s coming up. It&amp;rsquo;s the next one. But I want to ask the last question for Riak because I think you&amp;rsquo;re more familiar with that. Other than e-commerce sites such as Amazon, what are other use cases or scenarios that can benefit from high availability?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: There are all sorts: we have video games companies that are using our stuff to be the back-end for user data and session data, etc or even switching devices where for example on a lot of games you can play on multiple devices: you can save state in one and pick up another and continue playing. These kinds of things are at a very large scale. (They) seem trivial but they&amp;rsquo;re very hard to get right and you can&amp;rsquo;t really have a lot of latency in those cases. So it goes beyond just simple shopping carts. There&amp;rsquo;s also Riak CS which is great for asset storage. People store videos and images. As long as your values are small, you can store anything in Riak. Like I said, values are opaque so a value can be an image, just basics before encoded in whatever. It could just be small thumbnails if you&amp;rsquo;d like although I would recommend (Riak) CS but you could even use regular Riak as long as your values are bounded. But if you&amp;rsquo;re unbounded or objects, CS is a good option.&lt;/p&gt;

&lt;h4&gt;Part 6: Graph Databases&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Cool. The last one is a graph database and it&amp;rsquo;s Neo4j.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: I love Neo4j.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Isn&amp;rsquo;t it just social networks? What else?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;:  It&amp;rsquo;s not. That&amp;rsquo;s the interesting thing. It&amp;rsquo;s much more like a relational database in the sense that the relationships between values are as important as the values themselves. This isn&amp;rsquo;t really true for other NoSQL databases largely because you kind of denormalize them by design. We&amp;rsquo;ve talked about document data stores and key-value store and even column-oriented stores but when you have a graph data store, you can get the best of the worlds in the sense that you have the flexibility of normalizing or denormalizing as much as you want and you can then join values effectively by graph walking. What I mean by this is you start at a node and then your query is okay from this node find all the nodes that match these criteria. The criteria might be find all nodes that are adjacent to this node. That&amp;rsquo;s the simplest case. And that would be like a social network, say just find all friends. But it can be find all friends of friends: so walk two nodes out. And you can filter as part of these queries as well: find all friends of friends that graduated from this university assuming that data is in the graph somewhere, find all friends of friends that went to this university that themselves have a friend&amp;rsquo;s named Jeff. You can just keep building these ridiculously complex queries with something that you didn&amp;rsquo;t necessarily think of in advance. I&amp;rsquo;m using social network as an example because it&amp;rsquo;s the easiest case for people to wrap their heads around but there are a lot of things that you can use graphs for. One of my favourite ones, because I&amp;rsquo;m such a nerd about language and words, is you can have a graph-based thesaurus and your graph can be weighted as well. How close is this other word to this according to some weight? And you can look up some word like little and say what&amp;rsquo;s a similar word to little. Well, small is similar to little. You can also have antonyms connected and say okay big is connected to little but its edge will be labelled as an antonym, so if you&amp;rsquo;re looking for antonyms just do one step out to find adjacent antonyms. It&amp;rsquo;s a very quick look-up because once you found that first node, which you can just index. It&amp;rsquo;s a straight-forward look-up: find the word little and then find all the adjacent words to this. Now imagine doing this in a relational database. It would actually be kind of complex because you would have to replicate a graph in a relational style. You would have some table called words and you might have a join table that links a word to another word in some way, whether it&amp;rsquo;s a synonym or an antonym and now the way to find those synonyms or antonyms is to do a join from the word table to the join table, back to the word table. So it&amp;rsquo;s like a self-referential join. It&amp;rsquo;d actually become more complex to query it in a relational way than it&amp;rsquo;s in a graph data store version where we can just say I start at here, walk one node out, give me what you got. But you can also do really interesting things such as sorting by weight, which you could do in a relational way as well but now you&amp;rsquo;ve got to hang something off that join table. This is why one we created and joined the table in the first place so that we can have these weights and statuses of antonyms and synonyms. The sort of argument for Neo4j (this is something I&amp;rsquo;ve said in the book and something I&amp;rsquo;ve said in many talks before) is it&amp;rsquo;s a whiteboard friendly data structure. If you can draw on a whiteboard, you can just model it directly in that way and you&amp;rsquo;re done. The other thing is, you can add things that wouldn&amp;rsquo;t have necessarily thought of in advance. So besides having the query flexibility of something like a relational data store, you also have the storage flexibility of something like Mongo, Couch or Riak where you could say, I didn&amp;rsquo;t originally envision that our giant thesaurus graph: we might also decide to create a subgraph of books that contain those words and the link might be a count of how many times that word appears. So again, really simple look-up. I have the word best. What books contain the word best? I&amp;rsquo;m sure there&amp;rsquo;ll be a lot. Best of times, worst of times. It&amp;rsquo;ll be a lot of books but it would again be a very quick look-up. It would just say okay one step find all these adjacent values. It&amp;rsquo;s something you wouldn&amp;rsquo;t have necessarily designed in your system upfront but it&amp;rsquo;s something that you can add later. And the final thing that I think it&amp;rsquo;s really interesting is just the graph algorithms that you can do. In my book, the example I give is the &lt;a href="http://en.wikipedia.org/wiki/Six_Degrees_of_Kevin_Bacon"&gt;Six Degrees of Kevin Bacon&lt;/a&gt; example where I uploaded a bunch of movies and actors and say okay, walk this graph and find the shortest path between this actor and Kevin Bacon through movies that they mutually acted in. What was interesting when I uploaded this data set is I found the answers Neo4j gave me, despite having tens of thousands of movies and actors in it and the result would come almost instantaneously. The results are actually better than the same results in Wikipedia. For some reasons, Wikipedia has these values in it and don&amp;rsquo;t ask me why. So yeah, it&amp;rsquo;s interesting. Now there&amp;rsquo;s a downside and that being that you run into the same weakness that you have with a relational database in the fact that, in a general sense, node walking between different servers is difficult: so sharding a graph in the general sense is non-trivial thing, if it&amp;rsquo;s even possible at all because you can always make a supernode and you&amp;rsquo;ll just take your system down because every node has to walk through that supernode for non-trivial queries. I know that the Neo Technology guys are working on this, but it&amp;rsquo;s a very, very infant stage in my opinion. But it doesn&amp;rsquo;t make it less interesting.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: This has came to me and correct me if I&amp;rsquo;m not on the right track. Neo4j sounds more about data modeling. Its advantage is the way it models data. Is it possible to combine Riak and Neo4j?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;:  There have been attempts. Believe it or not, you&amp;rsquo;re not the first person to ask me this, but I&amp;rsquo;m not sure where the value would lie. They&amp;rsquo;re so fundamentally different. There&amp;rsquo;s better ways of searching something like Riak than trying to model it as a graph. One of the projects that &lt;a href="https://twitter.com/rzezeski"&gt;Ryan Zezeski&lt;/a&gt; and I, for what it&amp;rsquo;s worth, have been working on is called &lt;a href="http://www.youtube.com/watch?v=ETJqu5SmwOc"&gt;Yokozuna&lt;/a&gt; and it actually uses distributed Solr as a search back-end for Riak. It&amp;rsquo;s interesting because you can do distributed search on value and it&amp;rsquo;s very, very fast and you can distribute to dozens of nodes (not sure what the largest test has been so far and it&amp;rsquo;s still on alpha). It&amp;rsquo;s definitely interesting because you can query on data in a much more versatile way and simple key-value look-ups or even secondary indexing. The only reason I bring it up is because there&amp;rsquo;s just different ways of tackling the query problems of a key-value store.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;:  The other use case for graph database is it&amp;rsquo;s very natural for things like decision-making trees because a tree is basically a graph so a lot of the artificial intelligence side of problems would be a really good fit.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Part of the things that I like about Neo4j is that there&amp;rsquo;s a project called &lt;a href="http://jung.sourceforge.net/"&gt;JUNG&lt;/a&gt;, which is a toolkit of graph algorithms and probably the most famous and  its centrality algorithm is Google&amp;rsquo;s &lt;a href="http://en.wikipedia.org/wiki/PageRank"&gt;PageRank&lt;/a&gt;. It has these algorithms predefined in there so you just import the jar and you can just use them straight up. I think that&amp;rsquo;s pretty awesome because you can make your own tiny search engine in a very Google style way (Google doesn&amp;rsquo;t use PageRank anymore but Google style for small data sets circa 2004). I don&amp;rsquo;t want to give the impression that Neo4j can only handle small data sets. It can handle billions of nodes and billions of edges: you could model Facebook on a giant Neo4j server theoretically according to node and edge count. It goes back to scaling vertically v.s horizontally but that&amp;rsquo;s something they&amp;rsquo;re trying to resolve.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dingding&lt;/strong&gt;: Eric, you have introduced many databases. So if I start a new project, what should I choose? Do you have any suggestion on the choice?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Well, it depends. What kind of project is it and what are your consistency v.s availability requirements?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: What if I don&amp;rsquo;t have, for instance, I&amp;rsquo;m just building a web app pre-scale?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Yeah, that&amp;rsquo;s what I was going to say. If you don&amp;rsquo;t have any scalability problems and you don&amp;rsquo;t have any requirements. It&amp;rsquo;s sort of asking what should my favourite food be and giving no information about yourself whatsoever. It&amp;rsquo;s really hard to say. There&amp;rsquo;s just too many variables. I would say stick to a relational database, all things being equal. If you don&amp;rsquo;t know anything about your requirements or anything at all, there are enough toolkits and knowledge floating around out there that most of the time you&amp;rsquo;re perfectly fine with something like Postgres; Or if you want to be adventurous, then try Neo4j; If you know you&amp;rsquo;re building a system that has to be up all the time, then try Riak; If you&amp;rsquo;re building a system where you have multiple nodes that are barely connected but then they have to sync up every so often, then I would say try Couch: just install Couch on every server and let them sync up to some master node eventually; If you plan to scale to massive heights, like Facebook or Google size, then look at HBase. There&amp;rsquo;s my probably non-satisfactory answer.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: What about if I want to pick a database and so I don&amp;rsquo;t have to run migrations. That&amp;rsquo;s the reason to pick Mongo? Is it good enough?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Yeah, if you don&amp;rsquo;t want to run migrations, Mongo is a good one. Mongo is actually being sold recently not so much as big data, as much for fast implementation. So yeah, that&amp;rsquo;s an option but I wouldn&amp;rsquo;t necessarily overlook Neo4j in that case either. It has a query language called &lt;a href="http://docs.neo4j.org/chunked/milestone/cypher-query-lang.html"&gt;Cypher&lt;/a&gt; that I&amp;rsquo;m re-wrting the book and if I do come out with a second edition, I&amp;rsquo;ll almost definitely change this to use Cypher because it&amp;rsquo;s a sleek, cool declarative graph walking language and it&amp;rsquo;s pretty interesting. It makes it really easy to use a graph data store without having to write code in the way that you have to with &amp;hellip; It&amp;rsquo;s declarative but it&amp;rsquo;s still effectively code.&lt;/p&gt;

&lt;h4&gt;Part 7: Picks&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: I think that&amp;rsquo;s all the questions. Let&amp;rsquo;s get to the last phase of this episode, which is picks. Picks is basically where we invite the guest to share something interesting: something you have been doing or you&amp;rsquo;ve came across with and just share with the audience.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Sure. Recently, I was accepted to be on the &lt;a href="http://www.google.com/glass/start/how-to-get-one/"&gt;Google Glass Explorer Program&lt;/a&gt; so I&amp;rsquo;m actually toying with the idea of writing a Glass book if I have the time. We&amp;rsquo;ll see. But I&amp;rsquo;ve been enjoying researching it. Originally the announcement from Google was we&amp;rsquo;re only going to have a web-based only API and it&amp;rsquo;s called the Google Mirror API but at Google I/O last week, they announced that they&amp;rsquo;re going to have a native SDK so you can run native Android app because Glass actually just runs a version of Android. I think that&amp;rsquo;s going to be pretty amazing. I&amp;rsquo;m really excited about this. Somebody has already made one of the first Android apps called Blink where you just blink your eyes and it&amp;rsquo;ll take a photo. So I&amp;rsquo;m really to excited to get to play with this and we&amp;rsquo;ll see what pans out.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: That sounds fantastic. My pick this week is, I&amp;rsquo;m actually reading a book. It&amp;rsquo;s by &lt;a href="http://en.wikipedia.org/wiki/Nassim_Taleb"&gt;Nassim Nicholas Taleb&lt;/a&gt;. He&amp;rsquo;s the author of &lt;a href="http://en.wikipedia.org/wiki/The_Black_Swan_(2007_book)"&gt;The Black Swan&lt;/a&gt;. His new book is called &lt;a href="http://www.amazon.com/Antifragile-Things-That-Gain-Disorder/dp/1400067820"&gt;Antifragile&lt;/a&gt;. If you think &lt;em&gt;The Black Swan&lt;/em&gt; is one of his big ideas then this is where he puts everything together. He says in the book that &lt;em&gt;The Black Swan&lt;/em&gt; a prequel to this book. This is where a lot of his thoughts are coming together. The big idea for this book is he claims that the opposite of fragile is not robust: the opposite of fragile is something that gains from disorder, something that gains from chaos. There&amp;rsquo;s no word in English or any other language that can express this concept. So he coined this word called antifragile to capture this idea and he then applies this concept into many domains like social economics, food, health, philosophy and of course finance (that&amp;rsquo;s his background). So it&amp;rsquo;s been pretty amazing. I feel like it&amp;rsquo;s going to be one of the door-opening or mind-opening books.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: What&amp;rsquo;s an example of something that&amp;rsquo;s antifragile?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: For instance, rumours: the more you want to suppress rumours then the more they would spread. He actually uses the example of Hydra where you cut off one head and two heads would come out. If you say something is robust, that means it would resist chaos, it would resist change so at best it would not change but antifragile is something that if chaos happens, it would become more robust. This is a concept that&amp;rsquo;s not in any language or domains so he opened this door. I think it&amp;rsquo;s a fascinating book. It&amp;rsquo;s funny because the philosophy is much like reading Tao Te Ching because the more you try to impose structure, the more you try to control things then it becomes more fragile.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: The tao that can be named is not the tao. It&amp;rsquo;s awesome.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Yeah, so that&amp;rsquo;s my pick.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dingding&lt;/strong&gt;: Basically I have no picks so I&amp;rsquo;ll show you something interesting this week. I have watched the two videos recorded by Hashrocket with Eric and I think it&amp;rsquo;s very good. So I&amp;rsquo;ll recommend it to our audience and you&amp;rsquo;ll learn more about the background of this episode.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: One thing I should mention too is I just released a book a couple weeks ago. It&amp;rsquo;s on &lt;a href="http://littleriakbook.com/"&gt;littleriakbook.com&lt;/a&gt; and it&amp;rsquo;s just a short 60-page book that explains Riak and it&amp;rsquo;s free.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: OK, Eirc. Thank you so much for taking the time to talk with us today.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: That was a blast. Thanks.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: It was a great conversation. I learned so much more about database from this interview and I hope our audience will like it as well.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eric&lt;/strong&gt;: Thanks. I appreciate it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;All&lt;/strong&gt;: Take care. Bye.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;span class="footnotes"&gt;
  再次感谢&lt;a href="http://weibo.com/wuyicun"&gt;@吴怡村&lt;/a&gt;对于本期节目音频的整理。
&lt;/span&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>和李天放聊课程格子创业故事</title>
    <link rel="alternate" href="/2014/05/12/talk-about-kechenggezhi-with-tstyle11.html"/>
    <id>/2014/05/12/talk-about-kechenggezhi-with-tstyle11.html</id>
    <published>2014-05-12T04:00:00Z</published>
    <updated>2014-05-12T04:00:00Z</updated>
    <author>
      <name>叶玎玎</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;aside class="aside"&gt;&lt;img alt="课程格子" src="/images/talk-about-kechenggezhi-with-tstyle11/kechenggezhi.png?1399900780"&gt;&lt;/aside&gt;&lt;/p&gt;

&lt;blockquote&gt;
  目前 Teahour 的网站不适合放文本，需要重新设计，暂时先放我自己博客上。
&lt;/blockquote&gt;

&lt;p&gt;本文是 Teahour 第 34 期 &lt;a href="http://teahour.fm/2013/10/14/interview-with-tstyle11-about-kechenggezi.html"&gt;『和李天放聊课程格子创业故事』&lt;/a&gt; 的录音文本，欢迎大家订阅 Teahour，iTunes URL &lt;a href="http://itunes.apple.com/cn/podcast/teahour.fm/id608387170?l=en"&gt;点这里&lt;/a&gt;。Android 用户可以使用 &lt;a href="http://m.coolapk.com/apk/de.danoeh.antennapod"&gt;AntennaPod&lt;/a&gt; 来订阅。同时，欢迎加 Teahour 好友，&lt;a href="http://weibo.com/teahourfm"&gt;微博&lt;/a&gt;和 &lt;a href="https://twitter.com/teahourfm"&gt;Twitter&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;audio controls name="media"&gt;&lt;source src="http://screencasts.b0.upaiyun.com/podcasts/teahour_episode_34.m4a" type="audio/mpeg"&gt;&lt;/source&gt;&lt;/audio&gt;&lt;/p&gt;

&lt;h3&gt;Part 1 - 天放的工作经历&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：大家好，欢迎收听 Teahour 第 34 期，我是主持人玎玎。这期跟我一起主持的还有 Terry。Terry，你好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：Hi，大家好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：我感觉我好久没有当 DJ 了。刚经过了中秋和国庆假期，我还是很怀念这种感觉的。这一期我们很荣幸地邀请到了&lt;a href="http://kechenggezi.com/"&gt;课程格子&lt;/a&gt;的创始人李天放来 Teahour 做客。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：Hello，大家好。很高兴来到这里。我叫李天放，正在北京创业，做的是一个叫课程格子的手机应用，是一个给大学生用的工具。主打是课程表，是帮助你更轻松愉快的度过大学四年生涯的工具。我们是非常偏技术的团队，也一直在用 Ruby on Rails。来到这里和大家分享还是很开心的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：又来了一个 Ruby 社群的朋友。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：这个不是我们有偏向性，只是正好有找到一个 Rails 团队。上一次也是正好找到一个用 Python 的。所以我们 Teahour 是没有什么立场的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：天放隐瞒了很多他的背景啊。我想听天放分享一下他的工作经历，感觉会有很多不同。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我是在美国长大的，在那儿读小学、中学、大学，毕业后在微软的 Xbox Live 团队，为开发者提供平台工具。我 07 年去了硅谷，参加了一个小创业公司 —— &lt;a href="https://www.palantir.com/"&gt;Palantir&lt;/a&gt;，是做 2B 的东西，做大数据的。在那儿工作了 3 年后回到了中国。这家公司似乎默默无闻，没有融资等活动，直到...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;aside class="aside"&gt;
  &lt;img alt="课程格子" src="/images/talk-about-kechenggezhi-with-tstyle11/kechenggezhi.png?1399900780" /&gt;
&lt;/aside&gt;&lt;/p&gt;

&lt;blockquote&gt;
  目前 Teahour 的网站不适合放文本，需要重新设计，暂时先放我自己博客上。
&lt;/blockquote&gt;

&lt;p&gt;本文是 Teahour 第 34 期 &lt;a href="http://teahour.fm/2013/10/14/interview-with-tstyle11-about-kechenggezi.html"&gt;『和李天放聊课程格子创业故事』&lt;/a&gt; 的录音文本，欢迎大家订阅 Teahour，iTunes URL &lt;a href="http://itunes.apple.com/cn/podcast/teahour.fm/id608387170?l=en"&gt;点这里&lt;/a&gt;。Android 用户可以使用 &lt;a href="http://m.coolapk.com/apk/de.danoeh.antennapod"&gt;AntennaPod&lt;/a&gt; 来订阅。同时，欢迎加 Teahour 好友，&lt;a href="http://weibo.com/teahourfm"&gt;微博&lt;/a&gt;和 &lt;a href="https://twitter.com/teahourfm"&gt;Twitter&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;audio controls name="media"&gt;
  &lt;source src="http://screencasts.b0.upaiyun.com/podcasts/teahour_episode_34.m4a" type="audio/mpeg"&gt;
&lt;/audio&gt;&lt;/p&gt;

&lt;h3&gt;Part 1 - 天放的工作经历&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：大家好，欢迎收听 Teahour 第 34 期，我是主持人玎玎。这期跟我一起主持的还有 Terry。Terry，你好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：Hi，大家好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：我感觉我好久没有当 DJ 了。刚经过了中秋和国庆假期，我还是很怀念这种感觉的。这一期我们很荣幸地邀请到了&lt;a href="http://kechenggezi.com/"&gt;课程格子&lt;/a&gt;的创始人李天放来 Teahour 做客。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：Hello，大家好。很高兴来到这里。我叫李天放，正在北京创业，做的是一个叫课程格子的手机应用，是一个给大学生用的工具。主打是课程表，是帮助你更轻松愉快的度过大学四年生涯的工具。我们是非常偏技术的团队，也一直在用 Ruby on Rails。来到这里和大家分享还是很开心的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：又来了一个 Ruby 社群的朋友。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：这个不是我们有偏向性，只是正好有找到一个 Rails 团队。上一次也是正好找到一个用 Python 的。所以我们 Teahour 是没有什么立场的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：天放隐瞒了很多他的背景啊。我想听天放分享一下他的工作经历，感觉会有很多不同。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我是在美国长大的，在那儿读小学、中学、大学，毕业后在微软的 Xbox Live 团队，为开发者提供平台工具。我 07 年去了硅谷，参加了一个小创业公司 —— &lt;a href="https://www.palantir.com/"&gt;Palantir&lt;/a&gt;，是做 2B 的东西，做大数据的。在那儿工作了 3 年后回到了中国。这家公司似乎默默无闻，没有融资等活动，直到最近才有人发现，上了媒体报道。现在公司已经 10 年了，才慢慢有了名气，受到别人的注意和报道。&lt;/p&gt;

&lt;p&gt;我回来之后试着创业，做了 2 年多了，做过几个产品，目前在做课程格子。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：当初为什么想到要回国创业，而不是在硅谷做事情？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：当初我回来没有想创业，回来是见爷爷奶奶。从硅谷离开后，我想给自己放个假，去周游世界。但是我发现自己挺呆不住，就回到家里和家人一起玩。我们在东北，冬天特别冷。但是我不直到北京也特别冷，就跑到北京来玩。一开始我问了一下北京创业圈的朋友，听说北京有很多创业公司、投资人和很多互联网用户，我就想看看我能做些什么。当时，他们说不说海归，连 ABC 的成功率都是 0，是因为你不接地气，你也不够草根，也不了解屌丝用户。我觉得挺有道理，1 年都没有考虑过这些事情。&lt;/p&gt;

&lt;p&gt;后来，我的好朋友 Chris 在创新工场做投资。当时他们在做“助跑计划”，算是中国的 YCombinator。我也不知道，但觉得挺好，李开复老师也很有名，原来是 Google 的。他就说你来试 3 个月，试一试再说。当时我也没事干，我就来试着做一些事情。我就一个人去了。当时，我没有团队，没有钱，没有 idea，就去了创业工场，从那儿开始做了。我觉得创业做了点东西，别人说不好的时候，就会觉得很丢人。我会觉得自己能做得更好，就慢慢地往前做。回头一看，都已经两年半了。所以我创业的开始还是蛮随机的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：这两年半你在北京还适应么？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：我觉得北京是个特别适合工作的地方。因为天气不好嘛，冬天冷夏天热，待在电脑前写代码还是挺好的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：这个理由我还是第一次听说。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：你在微软做的东西是比较偏底层么？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：对，是很偏技术吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：就是和 Web 没有关系。那你的第二家公司呢？是做什么方面的？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我们是做 2B 的，用的是 Java，是 full service。有点像 Bloomberg，就是把整个 solution 卖个别的公司，让他们用自己的服务器跑。价格很贵，刚开始只有几百个用户，每个用户就要付很多钱。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：我研究了一下，为何你要放弃 Plantir 这样一个很好的机会回来呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：当时我就没有想太多吧。那是我们在硅谷不是唯一一家做 2B 的公司，要为一些大银行和大型机构做一些BD。我们旁边就是 Facebook 和 Twitter，朋友都是这个圈里的。他们就会说这周我们又增了 100 万用户，我昨天写了 1 个 feature，今天就有了 100 万次点击。我当时听了心里就很不平衡。作为一个程序员，你会希望写的程序会有很多人用到。而我们可能 6 个月才出一个版本，这个版本只有 10 个人用。我可能想做一个有大量用户的东西。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：需要一种成就感吧？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：希望有更多的人用。我花这么多力气给 10 个高端用户做定制不够好玩。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：这可能给后面做 mobile 和 web 垫下基础。最早在创新工程一个人的时候，做项目有没有做出来什么东西？包括前端都自己做吗？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：我当时做的是一个 Android 版本的交友应用，有点像陌陌。当时我一个人在北京，朋友很少，我会去豆瓣同城上找一些活动参加。我有一些奇怪的爱好，就是打 magic，我就想做一个 Android App，看有没有共同爱好的人一起去看个电影，吃个饭，交些朋友。这就是创新工场3个月做出来的项目，只有我一个人，只做了 Android 版本、Web 和很简单的后台。那个产品还是挺有意思的。但是交友部分就很奇怪。那时候我不懂运营，也没有经验，但做的过程中也有一些用户在用。我看了一下数据，男女比例就特别不平衡，男性用户有 87%。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：狼多肉少是吧！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：对啊。一堆宅男在上面自己玩，也玩不起来。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：说起来格子是你做的第几个产品？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：是我在中国做的第三个产品。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：第二个是什么？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：当时的计划叫 nada。活动这块很好玩，但交友就偏运营了。我也不知道去哪里找很多美女，或者至少是达人。干脆我们就把交友放弃了，专门做活动。国外有很多类似的产品，比如 &lt;a href="http://www.meetup.com"&gt;meetup.com&lt;/a&gt;，&lt;a href="http://eventbrite.com/"&gt;eventbrite.com&lt;/a&gt;，想去滑雪就可以在 meetup 上组个队，做公交或者拼车一起去滑雪。这挺有意思的，我们就把交友砍掉了，改了个名字，叫做计划FM（原使用jihua.fm），也是因为当时买不起 jihua.com。是一个社交化的 Calendar，这是我们第二个产品。我们先做了一个网页版，然后是 iPhone、Android，这个产品可能做了一年多。&lt;/p&gt;

&lt;h3&gt;Part 2 - 课程格子的创业故事和经验分享&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：你是怎么从第二个产品切换到课程格子呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：切换到课程格子是一个非常偶然的事情。我们当时做的日历，是一个垂直活动日历。我发现有好多大学生在用活动日历，他们会把学校的演讲、社团活动放上去。当时，我们就想这是很好地一个人群，大学里的活动的质量也很高。但是中国 IT 圈之外的活动其实去了很多都没有意思，有很多用户去了一两次就不去了。我们发现有两个好的圈子，一个是技术圈的技术分享，另外一个是大学圈，有很多演讲。我们就想专注做这两件事。&lt;/p&gt;

&lt;p&gt;我们怎么可以给大学生做一个更好的东西，也许我们可以做一个课程表，把他们的课程和活动放在一起，这样他们就可以在上课之后去参加这些活动。所以我们就做了一个 side project，花了一周的时间做了一个课表版本的计划FM，当时叫做课程计划。课程计划有点奇怪，就改名叫做课程格子。课程格子一开始就是一个 side project。大约是 12 年 4 月份我们做出了这个产品。结果这个一周做完的产品在 App Store 上，课程格子的用户增长远远超过了主产品。我们就觉得很奇怪，后来实在是受不了了。这可能是更垂直、更大的一个需求，干脆就把精力放在这上面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：刚开始做课程格子时候，你们的团队是怎么样的一个构成呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我可能带了一些硅谷的那些正确的做法。招人的时候，就把我们公司那一套，和 Google、Facebook 招人的方法搬过来。相对来说，要求非常高。比如我只招 full stack programer。一定要来了之后从前端到后台，数据、运维、CSS 和 HTML 都能写，这是我们的需求。这样我们就完全雇不到任何人。说起来有1年的时间直到我们转型，就招到了 2 个工程师，这就是我们唯一的团队。后面又雇到了 1 个设计师，我们一直是 3-4 个人。4 个人一直做到转型至课程格子。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;： 我听起来你们的 idea 好像一个比一个垂直，一个比一个偏工具。一开始可能是一个很 general 的 App，后来到了更垂直的活动组织，最后到了工具性质很重，也更垂直的一个工具。你们在最开始发现课程格子这么受欢迎，你预料到了里面会融入一些 social networking 的元素呢还是就把工具做好。是不是工具不能太满足你一开始的想法和初衷？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：这挺有趣的。我上周看了一篇文章，&lt;a href="http://paulgraham.com/"&gt;Paul Graham&lt;/a&gt; 写的。上面写到看到很多 YC 的 application，上面的 idea 好多都是把两个关键词拼在一起，变成一个新的 idea。比如我看别人做了一个活动网站，就把 social 加上去，我就是 social 活动网站。&lt;/p&gt;

&lt;p&gt;当时我们不懂，我们的 idea 都是这么想出来的。比如我们能不能拿一点移动的、social 的idea。比如豆瓣同城，我们就是一个移动的 social 的豆瓣同城，就是拿一些关键词随机的拼。我觉得这样超级不靠谱，这样拼出来的 idea 听上去都是挺好的，可以讲出道理，但是做出来没有人用。这可能是我们花了 1、2 年才得到的教训。就是这样拼 idea 是很不靠谱的。后来我们就不想这些 idea 或者关键词、定位、战略，就是找到一个很简单的需求，看到有人用，和用户聊你为什么要用这个产品。当时课程格子就是发现只有一个垂直用户的时候是多么好的事情。当时做计划FM的时候，有的人是互联网圈的，做 IT 技术讨论、互联网讨论，有的人说可能想去电影，有的人在大学当课表在用。你做用户调研的时候，要跟 5-6 种非常不一样的人聊，他们完全不是一个人群，有些是学生、白领、年轻人、老人。这样去聊会聊出一堆需求，没有办法拿用户的反馈做任何事情。我们做课程格子的时候，发现所有用户都是大学生。作为一个产品经理、程序员，这是一件非常好的事情。你和 10 个用户聊，虽然他们需求不是一模一样，但是非常接近。他们给你的反馈也是非常一致的。我们发现做一个垂直领域的时候，用户的需求就会特别靠谱，有价值。这样我们才越做越窄。一个非常小的用户群和需求可以让我们更好地设计产品。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：从一个 segment 入手，相对来说更容易一些。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：但是有没有想到过这样的群体比较窄，而且是学生群体。从 bussiness model 来讲，向他们收钱听起来不太靠谱。有没有想过这方面的问题呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我们开始没想太多这个方面的。一开始拿这个产品和投资人聊的时候，是他们提出了这个问题。我说我们找出了一个特别好的产品，增长特别快，用户特别喜欢，数据也特别好。而且没有人做大学生市场。创新工场的 partner 投资人就说这是有原因的嘛，因为大学生市场里面有一些天生的短圈。用户群有限，只有 2、3 千万人，第二个是所有的用户 4 年后就不是大学生了，他们是移动人群。第三个是消费力低，大学生没有钱。所以别人不做是有原因的，不是你们才找到了这个用户群。&lt;/p&gt;

&lt;p&gt;他说的挺有道理的。因为我们也不是 MBA，也不是做咨询的，肯定是不能分析出一个比别人好的产品，就不要想这个事情了，看看能做到什么情况。我们知道这些不完美的地方，但也许我们可以在中间找到一条路。虽然只有 2、3 千万人，但是这是一个很大的用户群，而且还是有很多真正的问题需要解决的。假如我们做的够好，这里面还是有很多有趣的事情可以做的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：我觉得有一个比较好的地方是这个群体是不会缩的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：但这个问题可能是你每年都要做一些宣传。如果没有跟上，你的用户可能就不会使用产品了。毕业后的用户虽然很忠实，但是还是不会再用了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：所以我想知道格子有没有计划去留住着一些人。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我们的产品和战略都是想去模拟真实世界发生的事情。第一次创业，我们都是想去改变人们的行为，改变社会的行为。但是发现这件事是不可能的。其实真正的大学生毕业之后，还会和大学的同学 keep in touch。特别是好的大学，都会有一个群，所谓的 Alumni Club。&lt;/p&gt;

&lt;p&gt;比如一些学长，还会和学校有联系。比如一个同学在某个大学毕业后，去了一个公司，可能两三年后这个公司回来校招，可能他就是校招的带领者。因为他会演讲，会讲自己的一些故事，帮助学弟学妹找到工作机会。这是一个 example。毕业不是一个结束，至少有一些方式我们是可以留住这些用户的。但是像 Linkedin 和 Facebook 这样的公司还是证明这样的事情是可以做到的。因为我们才做了 1 年多，做的是课程表。课程表用的最多的是大一、大二的学生，因为大三、大四的学生课比较少。所以我们觉得我们还有时间。不用因为毕业用户的流失担心，我们至少还有 1 年的时间去 figure out 这个问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：所以就是且行且看，遇到问题解决问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：非常好的一点是每个变化都是有数据在支撑的。是根据真实数据，而没有太多的试错。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：我想了解一下你们团队现在的情况。你们完全在做课程格子这个产品了，我想知道你们团队的规模。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我们融资之后也只有 5 个人，2 个程序员，1 个设计师，1 个客服，客服也是我们的产品经理，1 个人做其他所有的杂事。我们这5个人的团队很稳定。直到今年的3月份，我们还是这个规模。后来发现我们只做课程表，5 个人的团队已经足够了。我们发现大学里还有一些其他的需求，没有人来解决。所以那时候我们就下定决心拓展一下团队。最近的半年，团队的增长比较多，我们现在有 10 多人，不到 20 个。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：能谈下分工么？我知道很多团队客服可能是一些 manager，也可能是程序员。能具体聊一下为什么客服很重要？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我没有在中国上过学，而且已经毕业了，是 80 后不是 90 后。我做一个大学生产品，肯定不能挖掘需求。所以有一个非常好的渠道和大学生聊。其实真正聊需求是需要很高智商的事情。你不能把用户当做自己的产品经理和设计师。你可能听到他有很多 idea，但是你得知道他 idea 后面的痛点和需求。我们花了很久的时间来做这件事情。&lt;/p&gt;

&lt;p&gt;而且我们的客服就是产品经理。在中国产品经理是个很吃香的职位，不需要编程。我面了好多人，都没有合适的人选。作为一个工程师，我不需要产品经理给我文档。我们的产品经理是主要面对用户，是去听他们的故事、他们的痛点的人。听你说我们是以数据为导向的，其实这只占 3-4 成，和用户的对话占 6-7 成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：你刚才提到产品经理通过一些渠道去和用户交流。你们是怎样从用户那收到反馈意见呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：一开始，我们用了一个反馈工具。打开 App，在课表设置、反馈里可以在里面给我们反馈。这是最早的渠道。后面我们做了一些 social 的功能，所以我们有聊天。我们每个人都有账号和一张课表，但是是假的。有的时候就用聊天和用户沟通。我们也花了一些时间去做微博和人人账号，都有几十万的大学生。还有一个微信账号，这是一个和用户沟通的好方式。我经常也会到微博上去搜一下“课程格子”，有的人会分享一下他们的课表，我有时会在底下留言，比如“你的课表好漂亮”、“你的课怎么这么少啊，你是学什么的”，就是这样和用户在微博上搭讪。这是我用的主要的几个渠道。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：听上去既有主动的，也有被动的。被动的可能就是让用户主动来找你们，主动的就是你在微博。我想知道你们在主动的这方面还有没有做更多的东西？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：在线下还有。我觉得进校园是最好的一个方式，比如直接去学校。我也去过中国不少的学校。特别是要出北京。可能北京的学校都是比较好的学校，不能完全代表全国的各个大学。比如我们去过青岛、武汉、上海、广州这些地方。去大学里找一个学生会、社团，和她们做一些面对面的交流。我们一个月也会组织一个访问课程格子办公室。让北京一些用户，给她们一些吃的，每人一件 T-shirt，让它们用我们的产品。多创造一些线下的机会。有一个特别的好处，我们可以让工程师和用户一起聊，看他们用 App，看到一些 bug，和设计的不好的地方，是一个很好的动力来源。每一次我们的工程师做完用户调研后都特别有动力，当天就说我一定要把我看到的 bug 立即全部修好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：相当 Nice。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：你们有没有做过很多接地气的团队都要用一个 QQ 群。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：当然我们是有一个 qq 群。但可能不是主要的渠道。作为一个程序员，我的 IM 工具都是关的。我非常害怕那些 real time 打断我的聊天方式，所以我都在用 Email 和微信这种方式。QQ 群我不用，但是我们的客服小朋友们都在 QQ 群里聊天，帮助用户
。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：有点意思啊。听你说你们已经有 10 多个人了。你每天还在写代码吗？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：大概两个月前我80%时间还是在写代码、code review。现在团队变化比较大，新人比较多，写的代码比较少一些。但还是很多时间讨论设计，分模块，code review。code review 还是比较多，我就看每个 checkin，看大家写代码，大概花了一半时间在上面。其他的就是和用户聊天，考虑下一步做什么。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：你介绍了很多方式去接触用户。你也收到了很多反馈。有很多可能是你想做的，但是资源是有限的，不可能满足用户的所有需求。你们在迭代中如何甄别用户的需求并排列优先级？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我们会把大家的 idea 收集起来，然后扔到一个 board 上。我们有一个专门存 idea 的地方。每一个 milestone 我们会拿出一些 idea 来讨论用户的真正目的是什么，如何用简单的方式去实现需求。比如有很多人想要在添加课程时增加搜索功能或者按院系排列。最后我们发现他们想要的是最快地生成列表。所以我们就做了从他们的教育网导入，比他们自己提出的 idea 都好。我们会找到真正的需求是什么。&lt;/p&gt;

&lt;p&gt;第二点是，我们 15 人中 9 人是工程师，hacking 是个好玩的事情，对别人可能是成本，但对我们是个好玩的事情。所以我们有个好 idea，就会发出去。我们现在有个系统，我们可以只给某些学校发 feature，我们可以在几千个学校里发 feature。不好的就砍掉。做错了也不是什么大问题，多做一些就多砍一些，慢慢尝试，这就是我们做新 idea 的一个基本理念吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：这个很有意思。我很少看到对 native 应用做 A/B testing，但是 web 这边的经验会比较多。我想请你多介绍一下。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：因为我们原来做计划，以网站为主，每天都会发布好多个版本，像是 A/B testing。现在干脆就是我们做一个新的功能，不好的就砍掉。我看国外的一些公司有一些好的实践。Tumblr 当年表示我们网站就只有 10 个功能，我们出 1 个功能就砍 1 个功能。这可能就是磨合产品的过程。我们没有用特别的高端技术，比如 HTML 5。就是把功能加到客户端，下一个版本去掉。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：但是 App 这方面用户升级不是需要成本吗？你们就这样试？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：但是用户不会每一个新版本都更新。但是当你有了 100 万用户这样的规模的时候，给 10% 的人出一个 patch，其中 10% 安装使用了，还是有 1 万个人使用了。这样就有足够的数据看这功能好不好用，他们喜不喜欢。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：我想回到原点。你们从计划转过来，一开始可能只有课程表的功能，用户的接受度可能需要花时间权衡。你们是怎么看 MVP 这件事呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我们觉得 MVP 特别重要。第一是节省资源。第二是证明你想清楚了。有的时候你的 MVP 功能太多，你不愿意做 MVP，你可能就没有真正想清楚你想做什么。如果一开始你的 idea 只是随意拼凑的，比如一个社交化的旅游分享社区。这样你是很难拆出一个 MVP 的，你要从功能的角度取代。我觉得 MVP 就是一个特别明确的列表，就做三件事情。对我们来说就是：生成课表、分享给朋友、添加课程。这就是我们第一版的 MVP 的三个 feature。我觉得想清楚三个 feature 就发出去，这是一件好事。发的功能越少，做用户数据分析也更简单。只发一个功能，所有的数据和问用户都会关于这个功能。所以我们是很喜欢 MVP 这样的模式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：当你发布第一个版本的时候，第一波推广是如何做的呢？你会需要特定的用户去评价这个应用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：资源上的限制对我们是挺好的。我们第一版只支持 10 个学校。别的学校在注册的时候就会提示不支持，对不起，请等一等。所以限量是一个好的办法。我记得知乎这个产品当时就用了一个不正式发布的方式先运营。第二个是一开始我们需要的用户不是很多，可能 100 个就够了，所以是可以用很高的成本去获得用户。像国外的一些 startup，先做一些不 scale 的事情。这是我们学到的一个道理。因为工程师可能从第一天就开始考虑方案怎么 scale 到 10 万、100 万用户。但是一开始用一些不 scale 的方法可能是最好的。所以第一版我们雇了一个北大的学生组建的咨询公司，雇了 7 个小朋友帮我们做咨询。要求就是每天用课表，告诉 5 个朋友，相对来说我们还给了他们每个人挺多钱的。所以我们的前 100 个用户的获取成本可能是每个上百块。但是也无所谓，因为只有 100 人。所以这个方法还是挺好的。但是后来就不要做这些事情了，太贵也没有意义。但是前 100 个用户可以不惜任何代价获取。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：我觉得这样新用户就会非常愿意给你意见。这可能就是我们做的比较差的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：那么过了100个之后，你们的推广手段是什么？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我们第一天有个非常清楚的理念，就是这个产品不能推广。第一个就是线上的广告对我们是不划算的。比如一个广告在应用市场上看到的人里，10 个人里面可能不到 8 个人不是大学生。我们的推广成本就会比别人过 5-10 倍。第二个是大学生群体是流动人群，这样我们就需要每年推广，每年都会有百万大一新生进入系统。所以我们决定不推广，而是让用户滚起来。&lt;/p&gt;

&lt;p&gt;我们一开始就内测了几轮后，就在 2012 年秋季学期正式发布了 1.0 版本。我记得我们是 8 月 29 号上线的。9 月 1 号很多学校开学，我们就看市场的数据。一个很 lucky 的一件事情就是，我们当时的设计可能很干净，苹果可能就给了我们一周的 editor 推荐，对用户增长很有帮助。我记得计划FM 1 年还不到 10 万用户，那时还没有关。开学的第一周课程格子的用户就超过了计划，我们做了 1 年的产品。所以那一刻我们就决定做这件事情。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：那这个产品就真的解决了一个用户痛点。听起来就是一个 organic 的增长，也没有做什么宣传，口口相传就达到了很好的情况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：但是应用市场有这么多应用，我可能有课表的需求，但我不一定会去搜，或者也不确定怎么解决。但是总要有一个渠道去让我知道这个东西。我不知道你在这个方面做了什么事情。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我们做了一个很接地气的事情，很草根的事情。我们建立了一个校园大使的系统，我们会在每一个学校会找到一个学生代表，这个同学告诉他朋友，我们会给他一些资源，一些 T-shirt，抱枕、小卡片、卡套、笔记本这些小东西。他们可以用这些做活动。这个系统可能有点像实习或者众包，是这两个维度之间的事情，我们就把他叫做课程格子校园大使系统。这是非常有用的。他可以让一个学校没有任何用户的时候，从 0 到 50 个用户的期间，全部可以靠这一个同学影响到。校园是一个很封闭的地方。从 50 个到 500 个到 5000 个反而是相对自然的。但是没有人用就真的没有人用。这是一个用户增长的一大因素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：我可能对时间线上有点混乱。开始你限制了 10 个学校，正式发布放开了限制了吗？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我们是 2012 年 4、5 月才开始想这件事情，6 月才去发新版本，当时的时机也不是特别好。我们发版本的时候大家都快放假了，课都快上完了，都没有什么人用课表了。那时我们想第一个学期做 10 个学校，第二个学期做 100 个学校，第三个学期做 1000 个学校。这是当时我们的计划。然后做到第二个学期的时候，开到了 100 个学校。最后发现前一周下载量很多，90% 的用户下载后就说我们学校不能用，就在 App Store 上给我们 1 星的评价，说为什么不支持我们的学校。当时我们也很头疼，就取消了这个限制。也没有想太多，很多人在客服上找我们。所以就放开了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：刚发布时 Android 和 iOS 都有么？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我们先发的 iOS，当时我们是想做计划的时候，先做 iOS 可能产品可以做的更爽一点。一年前 Android 还没有这么快，一些高级的动画还很卡。我们先把 iOS 做好，先做口碑，做个用起来很爽的 App。结果后来发现大学生里 iOS 和 Android 的比例差距太大了，不做 Android 是不行的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：我也是这么想的，所以我就在想为什么一开始做 iOS。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：我想八卦一下这个数据在大学生里是什么样的。Android VS iOS。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我们也做过市场调查，大概 3：1。我们先做的 iOS，并持续被苹果推荐，9 月份推荐了两次，给我们带来了很多下载。一开始我们的数据是 95% 的用户是 iOS 的用户，之后每个月 iOS 用户的比例都在跌。现在大概是已经将近 4：1（70%），这个比例还是在每天增长。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：这两种手机价格差别太大了。特别是在太学生群体里。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：是的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：刚才听了你的推广思路，都是挺好的。你有没有什么推广的失败案例，踩错的点？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我们一开始想找一些大公司合作。但合作方式收效甚微，很大的公司也不太搭理你，给你资源。第二是我们当时也做了一些周边的 App，用小 App 给大 App 带流量。所以一开始就做了一些校花的 App，社团助手。还有大学生喜欢打 Dota，我们就做了一个 Dota 的 App，猜谜和战略。我们可能做了 7、8 个 App 发出去，App 里还留了很明显的课程格子广告。这些事情可能不成功，而且很分心。我们最宝贵的资源是开发、设计和产品，但是浪费在上面很不好。这可能是我们做的最糟糕的选择。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：你也提到和大公司合作，上个月你们有一个招聘模块，可能还是要和大公司合作吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：其实招聘数据是很好获取的，基本都是公开的。写一个爬虫，1 天就能拿到所有的数据。但是真正要把招聘做深。因为公司招学生是一个 B2C 的东西，公司的资源是我们没有办法获取的。&lt;/p&gt;

&lt;p&gt;有很多51，智联，这些公司就是非常 2B 的公司。做产品的可能不到他们公司不到 1% 的人。我们的第一步没有做到这么深，也没有招聘。还是从需求的角度。这几年大学生可能非常不好找工作，所以我们就和他们聊。很多人说他们非常担心找不到工作，所以就去所有的校园招聘投。只要有可能，就去海投。海投是他们的关键词，他们不关心去哪儿，但只要去得足够多，能找到一份工作就很不错了。当然最好的学生肯定不是这样子。但 90% 学生是这样想的。所以一个学生平均会去很多个校园照片，管理这个需要一个 Calendar。我们就做了一个很简单的 feature，你可以看到你学校和周边学校的招聘活动。你可以把它添到你的课表上，这样可以在上完第 6 节课，我就去这个招聘活动。比如你要在 9 月到 10 月去 15-20 个招聘活动是需要一些管理的。我们通过这个思路去做了一个校园招聘助手。但我们离真正的招聘公司还差很远。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：也是从用户的需求。我大概能理解。你们做格子时还在创新工场么？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：创新工场只有 3 个月。我们做计划FM的时候就已经搬出来了，现在已经有两年没有回到创新工场了。我们 11 年 6 月份就从工场离开，在外面自己做。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：因为我最近看到你们有在&lt;a href="http://www.yunjiasuqi.cn/%E2%80%8E"&gt;微软云加速&lt;/a&gt;的 program 里面。
&lt;strong&gt;李天放&lt;/strong&gt;：对。我们是 13 年 7月 加入计划，这是很好的一个机会。我们在创新工场还是有很好的体验的。大家会说很多创新工场的好处和坏处，他们的口碑也是很复杂的。但是我还是有很好的体验，我回国之后在中国没有任何前同事，很少的朋友，也没有任何圈子。所以创业还是需要一些资源的。&lt;/p&gt;

&lt;p&gt;包括招人。你一个人在外面，没有任何圈子，连实习生你都招不到。所以我一开始去创新工场，当时有20多个团队，都在一起，所以跟其中几个团队变成了好朋友，从他们那里得到了很多指导。然后我们就出来了。因为这可能在最早期的阶段很有用，但是后面的阶段要自己去探索。但是今年3月份，我们雇了很多人，从5个人到15个人，2/3的团队是第一次创业，很年轻，我们觉得有一个好的 incubator，对他们的成长是很有帮助的。他们可以看看别的创业团队是怎么做事的。这是我们去微软云加速最大的原因，给我们的新的同学一个好的 social 环境。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：Cool，这已经涵盖了我想问的一些问题。给一些创业团队意见要不要进入一些孵化器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：关于孵化器，最好的是可以把融资和环境分开来看。作为一个 VC 孵化器，作为一个环境提供者很糟糕，一定要分开来考虑。这是我们得到的最大的经验。&lt;/p&gt;

&lt;h3&gt;Part 3 - 课程格子的技术选择&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：OK。我们毕竟是一个技术型的 podcast，我们回来聊一点技术。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：好，我等了很久了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：我想请天放介绍一下技术栈。听下来计划和格子的技术栈是很一样的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：对。我们的前端都是 native，没有 share 任何东西，Android 和 iOS。后台是 Ruby on Rails，用的 MySQL，Redis。主要还是 MySQL 用的比较多。所有东西在 Linux 上面。聊天是用 Erlang 写的。基本上是这些比较大的模块。还有一个搜索的模块，搜索课程、教室、老师，用的是 Sphinx，Rails 这用了 thinking-sphinx。基本上是这样。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;: ok。聊天这部分你们是自己做的，还是用了一些现成的 ejabberd 这样的东西。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我们是用了 ejabberd，后来自己打开，改一些自己需要的东西。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：听起来和我们挺像的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我们可以交流一些。我们的团队经验可能没有你们多，技术团队是比较缺乏经验的。哪天可以请教一下。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：太谦虚了。我想知道你说的这样的 full stack。除了 server 端的，Android 和 iOS 都是你自己会的么？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：计划的第一版是我写的。我们第一个工程师非常好，现在是我们的技术总监，算是 full stack。把 Android 和聊天接过来了。所以很久一段时间，我做iOS 网站和后台，他做 Android 和聊天。现在我们是有 8 个全职工程师了，每块都有很专业的人来做了。我做也有很多不了解的东西，就去网上搜一搜，尽量用最便宜的方式实现。现在我们 iOS 和 Android 各有一个团队。后端就没有分那么多，包括 Web、数据、逻辑、聊天、API 一起做。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：我想了解一下 web。你们还是一个 mobile 的应用，你们在 web 上做了哪些呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：非常少。我们的 web 基本不是对外的。因为我们有个校园大使，就做了个后台管理这些大师，他们的成绩。我们可以给她们分发一些任务。这可能是很长时间我们唯一的 web 产品。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：相对来说，用户使用你们的东西全部都通过手机 native 来走。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：是的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：那相当于你们只有 API 接口。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：是的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：那我想了解一下，现在有很多新闻都在说 LinkedIn、Twitter、Groupon，都从 Rails 换到了 Node。作为一个中间层。我想知道你的看法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：对，我觉得这也是在我们计划之内。我们有好多台 web server，用户也没有那么多。我在买机器的时候就在想真的需要这么多吗？我听人家说你换成 Go 就可以把 20 台服务器换成 2 台了。但可能一直比较忙，创业的挣扎时候，赶进度的时候就疏忽了。我觉得我们可能会尝试一些，把一些最慢的 API call 一个个转成比较高效的技术框架。一开始我们是有个网页版的课程格子，但经历不够就砍掉了。一开始选 Ruby on Rails 是因为 API 和 HTML 一起支持其实是挺干净的一套系统。后来不做 web 了，我们的选择又多了很多了。但是还没有换。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：你会不会觉得，用着用着 Rails 就不符合你们的需求了。你们是纯 API 的，你们有没有尝试过一些别的 Ruby 框架？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：最近我们尝试一些小的新功能的时候都是用 Sinatra 在做的。分享看代码的时候都会干净很多。现在我们做主页之类的时候，我们的设计师可以自己写 HTML、CSS、JavaScript，但他们装 Rails 是很麻烦的。我们的 Rails 用了很多插件，他们装个 ImageMagick，装个 Sphinx，装个 Redis，对设计师很麻烦。所以我们用 Sinatra 就一个文件，做好就可以直接把写好的 CSS、HTML 同步过去了。所以觉得 Rails 在很多人碰的时候有点笨重。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;： 我也觉得 Sinatra 做 API 蛮爽的。但你们也提到你们有很多 server。你们一开始就是考虑 dedicate server 而不是从云开始用吗？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我们是 11 年开始做的，那时好的云服务不多。在国外我们一直用 AWS，也会有点不习惯国内的云服务的用户体验和接口。跟 AWS 比起来都太土了，用起来很不爽。还有一个考虑是，我们很多大学生是在校园里面，我们不知道中国的网络情况。所以我们就专门找了一个可以多线的 hosting。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;: OK。那你们现在有多少 server。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：可能有 2、30 台吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：你们会有专门的 SA 来管吗？还是你们的程序员来兼做 SA？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：一直到今年 7 月都是我在管，没有人愿意做这件事情。大家说 CEO 不就是来扮演扫地的吗，只有我一个人和机房打交道。7 月份来了一个运维很专业的同学，他原来在游戏公司做过，也做过很大 scale 的。然后他就把这块接过来了。我们一直没有找到很好的运维工程师。要是有的话，我们还是需要的。因为管机器还是很花时间和心思的事情。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：我还是要澄清一点，只是 Rails 不太适合你，但是 Ruby 上还是有很多可以走异步的。你现在只要把 Rails 的 controller 和 request 部分改写了，像 AR 就可以继续用的。这样也可以达成 20 台变成 2 台的目的。但是你要用异步去弄。各种 API framework 在 Ruby 这都有。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：我记得&lt;a href="http://huangzhimin.com"&gt;黄志敏&lt;/a&gt;好像分享过一个&lt;a href="https://speakerdeck.com/flyerhzm/gou-jian-yi-bu-apifu-wu"&gt;这样的经验&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：因为这是他在 OpenFeint 的真实经验，20 台变成 1、2 台机器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我觉得这很好，event machine 我们也在看。我们一直在用 Passenger，试图把它们改成 Thin。因为请求特别多，每个请求其实还是挺便宜的。我们虽然是一个程序员为主的公司，但很多东西都做得不是最高效的。一开始我们选择了 VC 这条路线，没有走 lifestyle 的路线。有一些投资人会给你一些压力让你尽量追赶业务。有的时候我很羡慕自己可以 bootstrap 起来，从零开始，100% 按照自己的想法来说。不能说控制吧，投资人也没有控制我们，比如我可以花 6 个月的时间优化清理代码，现在有的时候我在做这件事情的时候，就觉得是不是太对不起我们的投资人了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：你们有没有统计过课程格子的后端代码有多少行了？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：多少行我从来没有看过。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：因为他模块挺多的。所以很难估计。&lt;/p&gt;

&lt;h3&gt;Part 4 - 格子的工作流程和团队文化&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：那我换一个问题，你刚才也提到了团队大了，你会做一些 code review 工作，大家的水平慢慢会有点层次不齐，你们的 process 是怎么样的？怎么样做一个 code review，怎么样做一个 feature，怎么样开发？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：还有怎么样来培养人？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我们一开始的 process 是很乱的。因为 3 月份我们只有2、3个工程师。都不用动同样的代码。我们一直在用 git，代码在 github 上。但我们没有一个 git process，大家自己使用 branch。一开始我们用 git flow，觉得不太适合后台。因为后台不用每次上传一个 tag，稍微简化了 git flow，我们有一个 develop branch，一个 master 是随时可以发布的。每个人在自己的 branch 上面，所以的 code review 是通过 git 来做。其实我有的时候在 github 上看一下大家新的动态。不是特别 formal。我们有一个 stage server。我们所有东西都放在 stage server 上，大家都有 push 权限。因为太多代码我看不过来，我会大致看一下。新同学来的第一个月，我会每天看他做的所有事情。等到他基本掌握了我们的风格和知识的时候，就基本 independent，不要求 code review。一个月之后，你觉得你需要 code review，就叫一个人来帮你做。我们现在是这个状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：是只有你在做 code review 还是交叉 review？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：任何人。还有些是专门的，iOS 团队互相做 code review，Android 团队两人互相做 code review。我们的模块比较多。后台大部分是我在做。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：那你们会用 pull request 吗？个人的 branch 怎么进入 master，是提一个 pull request，还是告诉你做完了，让你来 review 后merge。是怎么样的情况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：是后面的情况，我们没有用 pull request。我们直接 review 后 merge。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：正好你说了这两点，我在 blog 上有分享我们团队的经验，第一篇是 &lt;a href="http://yedingding.com/2013/08/08/dig-into-code-review-process.html"&gt;让代码审查成为你的团队习惯&lt;/a&gt;、第二篇是&lt;a href="http://yedingding.com/2013/09/11/practical-git-flow-for-startups.html"&gt;实用 Git 工作流&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我之前看过第一篇，但是没有看过第二篇。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：有一篇是讲我们的 git flow 的，另外一篇是讲我们如何做 code review 的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我看过第一篇，那个 blog 对我们是有启发的。我们当时没有 process，所以在建立 process 的时候就在网上搜，就搜到你的 blog，觉得这是个好的主意，好像是这样我才发现了 git flow。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：我不知道你们还要不要人？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我们非常需要人。我们到了一个规模，可以再想一下除了课程表还可以做些什么东西。每个东西都是一条产品线。我们是非常缺人的，是我们最大的一个瓶颈。我都忘了我第三个主要工作，就是招人。相对来说，我们还是蛮挑剔的。
刚开始时，我的渠道不太对。我也不知道怎么招人，我就在51和智联上招聘，就来了好多人投简历。一开始我很兴奋。第一天我的 admin 给了 400 份简历。我觉得这里面至少可以找到 10 个好的程序员，我就花了好久时间全都看了，就发了笔试题，当面面试。结果 400 个里面没有 1 个可以雇的人，这给了我很大的打击。这样的话我们可能永远雇不到要的人，我们不能宅在办公室里，要想到一些方法找到一些好的人。我也是刚刚才意识到这一点。现在我就在想我要到哪里去找聪明的程序员。当然，找起来太不容易了，只要找到一个就尽全力把他弄过来。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：考虑到你们拒了 400 个人的经历，我能不能问一下你们的要求是怎样的？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我这是黑了一下智联这样的招聘网站。其实渠道真的差了很多。现在我们在 Ruby China 上发了一个帖子一共可能就 4-5 人回了，4-5人 里就有一个同学过来，非常好。他还没有毕业，我就已经给他了一个全职的 offer。他可能 10 月就会加入。&lt;/p&gt;

&lt;p&gt;4-5 个人里就能找到一个人，对比 400 个人一个都没有。所以不同圈子里还是有很多差别的。这两年我招人觉得第一个要聪明，悟性高，学习能力特别强，基本是唯一的要求。第二个上是 culture fit。我们的面试流程更接近硅谷，流程很长。一开始很短，请你过来之后至少有 3 个程序员和你聊。至少有 3 个 interview，我是第 4 个。这是一个双方的认识的机会。我们一共就 8 个程序员，你跟 3 个人聊过了也大概知道了工作的风格和人的风格。大家是喜欢什么，爱好是不是匹配。工作方式和理念、vision 都可以感受一下。&lt;/p&gt;

&lt;p&gt;我们每个人都会有一票否决权。从 culture fit 上，每个人都可以一票否决，其实很少用到，来的人都蛮不错的。而且做一个创业公司，每一个人都可以选择做事情的方式，和谁一起工作。给大家一票否决权，可以让大家觉得可以 control 我的 teammate 是谁，我的队友是谁。这就是我们的一个基本流程。一个是聪不聪明，第二是文化匹配。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：你会让面试者和你们一起工作一天了解他的能力和你们是不是匹配？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我们一些好的 candidate 过来，都可能要半天 4 小时。其实也差不多了。我们会给她们一些 coding problem，编程是一个很大的一部分。我们来之前是没有电话面试的，我们会给大家发一道题。这道题是很简单的。比如 iOS 题就是写一个列表，这个列表稍微有一些比较慢的计算，可以在不卡的情况下滑动列表，大约能在1小时内完成，就是我们的第一个面试，来讨论你为什么要这样写代码，或者为什么这样设计。我们可能会有一些基本的算法和数据结构，基本是这样的流程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：OK。你们现在因为分了很多全职，像 iOS，Android，后台都有。你们最缺的是哪个？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我们最缺的是后台。iOS 和 Android 挺稳定的。直到今年，最后 hire 的两个 candidate 中有一个 Ruby 经验的。前一年我们都没有雇到一个会 Ruby 的。Rails 其实是很好上手的，但用得好就比较难。所以我们很缺有这种经验的人。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：所以你们在招的主要也是后台的。要不要再说几句宣言，让大家来给你们投一个简历。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：好啊。我们也不能说我们是最牛的团队，但是有一些比别的公司好的，有价值的地方。&lt;/p&gt;

&lt;p&gt;第一个是，我是 1 号员工，我是程序员，我一直在硅谷工作。我至少直到一个好的程序员的环境是怎么样的。我在硅谷 3-4 年也看了很多好的团队，我不知道能不能在中国复制一个好的环境。但是至少是我的一个意图。我是想做一个特别好的 hacker friendly 的一个环境、文化，去用技术解决问题。&lt;/p&gt;

&lt;p&gt;第二个我们在中国走 VC 路线的团队的 size 是比较小的。A 轮之后，我们只有 6 人。我们也没有任何计划去扩展到 50 个，100 人这样。我们只招聪明的，比较适合团队的。所以环境还是不错的。&lt;/p&gt;

&lt;p&gt;第三是我们做的事情虽然不是特别创新，但是是自己慢慢琢磨在做的。因为国外没有课程表这样的东西。其实在中国做大学生市场的人也非常非常少。至少我们解决了一个值得解决的问题。也许不是我们现在做的这件事，但是是为了大学生这个市场。不但有商业价值，还是有真正的社会价值。&lt;/p&gt;

&lt;p&gt;为什么每年有 700 万的大学生花了 4 年时间和父母多年的积蓄，加上辛苦的高考，上大学。但出来的时候能做的事情非常少，这么多人找不到工作。所有的公司也都招不到好的员工。从一个大的角度上，这个 social structure 里是有一些很低效的。也许我们可以利用一些技术来把这些事情变得更高效。假如我是个程序员，我最关心的事情是，跟聪明的人一起工作，做一些有意义的事情，有一个好的 culture 好的环境，大家做的开心。我们就尽量把这三件事做好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：这是我们很向往的方向。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：大家有兴趣地赶快投啊。&lt;/p&gt;

&lt;h3&gt;Part 5 - Share Picks&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：我会在 Share notes 中留下天放的联系方式。那这期就到这里，我们进入最后一个环节。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：我先来吧，那我分享一下很老的一本书，是《&lt;a href="http://pragprog.com/book/btlang/seven-languages-in-seven-weeks"&gt;Seven Languages in Seven Weeks&lt;/a&gt;》。我现在看到 scala 这一章了。我觉得这本书很有意思。虽然这个分类有很多书了，但是这本我还没来得及看。我觉得程序员一段时间花很短的时间去了解一个 language 是很有意义的。可以帮助你更了解你现在用的 language。&lt;/p&gt;

&lt;p&gt;我觉得作者学语言的方法很有意思。如果你把这方法掌握了，如果你要快速了解一门语言，你也可以用这个思路去做。你也可以很快地掌握一个语言的本质而不是只是 Hello World。我推荐程序员可以读一读这本书。这个也是《Seven Languages in Seven Weeks》的第一本著作。也不算很新了，没有看过的我推荐大家可以看一看。这是我的 picks。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：说起《Seven Languages in Seven Weeks》，我想我们也采访过 seven database 的作者，然后我一直没有收到听众的一些反馈，也不知道大家对英文的接受度如何。欢迎大家反馈，让我们考虑要不要请《Seven Languages in Seven Weeks》的作者来 Teahour 聊。天放刚才说到一些process，我自己在个人博客上分享了一些如何做 code review 和git flow 的两篇文章。我会在 Share Notes 中贴出链接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：我推荐一本书吧，我十一期间看的一本书，叫做《Masters of Doom》。我在 Hacker News 上看到的。Doom 是 90 年代很火的游戏，是 Id 公司的创业历史。有个很有名的程序员——John Carmack。这本书可能是我1年来几十本里最好的一本。应该有中文版，可以在&lt;a href="http://book.douban.com/subject/1438119/"&gt;豆瓣&lt;/a&gt;上查一查。&lt;/p&gt;

&lt;p&gt;这本书是 90 年代的创业故事，是很 pure 的，没有这么多融资和浮躁的市场。就是两个人一开始想做一个游戏，做了一个非常非常大，几十亿美元的公司。&lt;/p&gt;

&lt;p&gt;第二点是里面的两个主角之一John Carmack。虽然是个写实的书，但把他写的像一个神一样。在碰到不可跨越的问题的时候，他就会用完全意想不到的方法解决问题。就像金庸小说的主角一样，他一个人过关斩将发明出来3D 的方式。我觉得非常励志。程序员 hero 可能没有那么多，如果你是一个程序员，你可以多一个 hero，多一个可以崇拜的英雄。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：OK。我们这一期就到现在为止。非常感谢天放来我们 teahour 做客。也欢迎以后可以再来跟我们做交流。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：下次再见。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;李天放&lt;/strong&gt;：再见，88，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：88。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Terry&lt;/strong&gt;：88。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;span class="footnotes"&gt;
  天放最近刚更新了课程格子的招聘信息，主要是招 Tech Lead、Ruby 工程师和 Growth Hacker，大家可以看 &lt;a href="http://kechenggezi.com/jobs"&gt;http://kechenggezi.com/jobs&lt;/a&gt;。
&lt;/span&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>与 Ari Lerner 聊 AngularJS</title>
    <link rel="alternate" href="/2014/05/06/teahour-51-angular-with-ari-lerner.html"/>
    <id>/2014/05/06/teahour-51-angular-with-ari-lerner.html</id>
    <published>2014-05-06T06:00:00Z</published>
    <updated>2014-05-06T06:00:00Z</updated>
    <author>
      <name>叶玎玎</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;aside class="aside"&gt;&lt;img alt="AngularJS" src="/images/teahour-51-angular-with-ari-lerner/AngularJS.png?1399900780"&gt;&lt;/aside&gt;&lt;/p&gt;

&lt;blockquote&gt;
  目前 Teahour 的网站不适合放文本，需要重新设计，暂时先放我自己博客上。
&lt;/blockquote&gt;

&lt;p&gt;本期音频文本非常感谢&lt;a href="http://weibo.com/wuyicun"&gt;@吴怡村&lt;/a&gt;的整理。本文是 Teahour 第 51 期 &lt;a href="http://teahour.fm/2014/04/21/interview-with-ari-lerner.html"&gt;『Interview with Ari Lerner about AngularJS』&lt;/a&gt; 的录音文本，欢迎大家订阅 Teahour，iTunes URL 是 &lt;a href="http://itunes.apple.com/cn/podcast/teahour.fm/id608387170?l=en"&gt;http://itunes.apple.com/cn/podcast/teahour.fm/id608387170?l=en&lt;/a&gt;。Android 用户可以使用 &lt;a href="http://m.coolapk.com/apk/de.danoeh.antennapod"&gt;AntennaPod&lt;/a&gt; 来订阅。同时，欢迎加 Teahour 好友，&lt;a href="http://weibo.com/teahourfm"&gt;微博&lt;/a&gt;和 &lt;a href="https://twitter.com/teahourfm"&gt;Twitter&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;audio controls name="media"&gt;&lt;source src="http://screencasts.b0.upaiyun.com/podcasts/teahour_episode_51.m4a" type="audio/mpeg"&gt;&lt;/source&gt;&lt;/audio&gt;&lt;/p&gt;

&lt;h4&gt;Part 1: AnguarJS talk&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Hello everybody and welcome to Teahour. This is episode 51 and today we have &lt;a title="Ari's Github" href="https://github.com/auser"&gt;Ari Lerner&lt;/a&gt;. Hi Ari.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: I worked at &lt;a href="http://www.att.com/"&gt;At&amp;amp;T&lt;/a&gt; for about five and a half years or so and at AT&amp;amp;T I was originally hired to build their internal competitor to &lt;a href="https://aws.amazon.com/ec2/"&gt;EC2&lt;/a&gt;. I helped build their internal cloud and I built what was actually one of the first open-source clones of &lt;a href="https://www.heroku.com/"&gt;Heroku&lt;/a&gt; entirely in &lt;a href="http://www.erlang.org/"&gt;Erlang&lt;/a&gt; called &lt;a href="https://github.com/auser/beehive"&gt;Beehive&lt;/a&gt;. In my later time at AT&amp;amp;T, I worked on their developer services. I helped build their single sign...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;aside class="aside"&gt;
  &lt;img alt="AngularJS" src="/images/teahour-51-angular-with-ari-lerner/AngularJS.png?1399900780" /&gt;
&lt;/aside&gt;&lt;/p&gt;

&lt;blockquote&gt;
  目前 Teahour 的网站不适合放文本，需要重新设计，暂时先放我自己博客上。
&lt;/blockquote&gt;

&lt;p&gt;本期音频文本非常感谢&lt;a href="http://weibo.com/wuyicun"&gt;@吴怡村&lt;/a&gt;的整理。本文是 Teahour 第 51 期 &lt;a href="http://teahour.fm/2014/04/21/interview-with-ari-lerner.html"&gt;『Interview with Ari Lerner about AngularJS』&lt;/a&gt; 的录音文本，欢迎大家订阅 Teahour，iTunes URL 是 &lt;a href="http://itunes.apple.com/cn/podcast/teahour.fm/id608387170?l=en"&gt;http://itunes.apple.com/cn/podcast/teahour.fm/id608387170?l=en&lt;/a&gt;。Android 用户可以使用 &lt;a href="http://m.coolapk.com/apk/de.danoeh.antennapod"&gt;AntennaPod&lt;/a&gt; 来订阅。同时，欢迎加 Teahour 好友，&lt;a href="http://weibo.com/teahourfm"&gt;微博&lt;/a&gt;和 &lt;a href="https://twitter.com/teahourfm"&gt;Twitter&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;audio controls name="media"&gt;
  &lt;source src="http://screencasts.b0.upaiyun.com/podcasts/teahour_episode_51.m4a" type="audio/mpeg"&gt;
&lt;/audio&gt;&lt;/p&gt;

&lt;h4&gt;Part 1: AnguarJS talk&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Hello everybody and welcome to Teahour. This is episode 51 and today we have &lt;a title="Ari's Github" href="https://github.com/auser"&gt;Ari Lerner&lt;/a&gt;. Hi Ari.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: I worked at &lt;a href="http://www.att.com/"&gt;At&amp;amp;T&lt;/a&gt; for about five and a half years or so and at AT&amp;amp;T I was originally hired to build their internal competitor to &lt;a href="https://aws.amazon.com/ec2/"&gt;EC2&lt;/a&gt;. I helped build their internal cloud and I built what was actually one of the first open-source clones of &lt;a href="https://www.heroku.com/"&gt;Heroku&lt;/a&gt; entirely in &lt;a href="http://www.erlang.org/"&gt;Erlang&lt;/a&gt; called &lt;a href="https://github.com/auser/beehive"&gt;Beehive&lt;/a&gt;. In my later time at AT&amp;amp;T, I worked on their developer services. I helped build their single sign-on gateway. I helped contribute to their next-generation text messaging gateway. So all the stuff that I&amp;rsquo;m referring to is all back-end services, really server-side heavy. So when I left AT&amp;amp;T, I felt like I was ready to go. I left AT&amp;amp;T with all this back-end experience and an idea for an application that I was writing kind of in nights and weekends at that time. And I wrote this beautiful calendaring system and I realized I had very little front-end skills, at least knowledge of front-end frameworks. I knew &lt;a href="http://backbonejs.org/"&gt;Backbone&lt;/a&gt; and I really did not like working with Backbone: writing so much code just to get simple things working. At that time, I thought there had to be a different way. So I started exploring different front-end libraries. I found &lt;a href="http://knockoutjs.com/"&gt;Knockout&lt;/a&gt;. I used Knockout for a little while and I found &lt;a href="http://emberjs.com/"&gt;Ember&lt;/a&gt;. This was Ember pre-1.0 days. And I found &lt;a href="https://angularjs.org/"&gt;Angular&lt;/a&gt; and Angular just felt right. Everything about writing Angular, even back then when it was quite young, I felt like it was onto the next generation of writing web applications. So I&amp;rsquo;ve been working with Angular since February of 2013, just a year and a couple months.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: That&amp;rsquo;s really interesting because that&amp;rsquo;s about the same time when I picked up Angular as well. I actually had very similar experience. I did some backbone development before Angular and it was very much an eye-opening experience when I looked at Angular. It was just amazingly easy to get started and be productive. The two-way binding. Was it Angular or was it Knockout that invented two-way binding?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Angular didn&amp;rsquo;t invent two-way binding but it invented the abstraction of JavaScript into the DOM.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: That was very nice because when I used to work with Backbone, I had to work with the DOM a lot, like write code, look at this element and etc. But with Angular, I felt like if I did it right I didn&amp;rsquo;t need to touch the DOM at all in my Angular code. That was very nice.&lt;/p&gt;

&lt;p&gt;So we can talk about Angular more a little bit. The other thing I liked about Angular was testing. I was surprised by how thorough it was. Maybe you can talk on that as well?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Coming from a back-end perspective where testing is really easy, there&amp;rsquo;s been a lot of thought over the past 15 to 20 years or so in software development about testing. Moving to the front-end back in those days (1.5, 2 years ago where in software it&amp;rsquo;s eternity), testing was almost unheard of. You have &lt;a href="http://docs.seleniumhq.org/"&gt;Selenium&lt;/a&gt; testing that are relatively arbitrary ways of doing front-end testing and managing your front-end from a test perspective. So it was really refreshing when you move to Angular where everything is tested and everything is written to be testable and you have these fantastic tools like &lt;a href="http://jasmine.github.io/"&gt;Jasmine&lt;/a&gt; and &lt;a href="http://karma-runner.github.io/0.12/index.html"&gt;Karma&lt;/a&gt; and nowadays with &lt;a href="https://github.com/angular/protractor"&gt;Protractor&lt;/a&gt; which is just awesome. Now if you&amp;rsquo;re writing an Angular app and you&amp;rsquo;re not writing tests you&amp;rsquo;re missing half the reason why you would use Angular in the first place.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: OK. Yeah, I think before Angular I was definitely doing  more of the Selenium, the whole integration testing. I think part of the reason was, before Angular my JavaScript code was really just everywhere: a lot of jQuery here and there. I wrote some JavaScript myself but there wasn&amp;rsquo;t really a good way even if I wanted to do the testing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Yeah, that&amp;rsquo;s one of the reasons when you move away from writing your application code as a one-off application. You move to a structure, where as you just mentioned, you have lots of jQuery embedded all over your application in somewhat of an unstructured way. Testing is hard. It&amp;rsquo;s also hard to maintain, to manage and to get team members working on the code base when everything is everywhere. That&amp;rsquo;s one of the benefits of using a framework.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: So let&amp;rsquo;s say when you work on an Angular app, what&amp;rsquo;s the typical workflow? Do you develop the front-end stuff separately, step out the back-end or I guess you still do integration testing for the whole full stack?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Yes, to test in Angular, you have the end-to-end test or the integration test. It&amp;rsquo;s also known as black-box testing. So basically the concept behind is that you&amp;rsquo;re automating someone opening a web browser and clicking around. So rather than every single time you make a change, using your mouse, reloading a page and clicking on buttons and making sure they work, you script that so you tell the browser what it wants to click on and move on and all that fun stuff. That&amp;rsquo;s end-to-end testing. Normally what I would do is I&amp;rsquo;ll write my end-to-end tests first. I&amp;rsquo;ll have an idea for my application and because the API, the functionality of my application will change as it naturally does (it always does) when you&amp;rsquo;re writing code. I tend to write end-to-end tests that match the functionality that I definitely know that I&amp;rsquo;m going to have. And as I was developing the app, I&amp;rsquo;ll run my end-to-end every once in a while and make sure that functionality still exists and fix it when it breaks and as I change the structure of application, I&amp;rsquo;ll change the structure of the tests. When things are settled out a little bit deeper I&amp;rsquo;ll start writing unit tests and unit tests themselves are exactly what they sound like where you&amp;rsquo;re testing units of code. When you&amp;rsquo;re writing a service, for instance, an Angular service, you would write a unit test for that service and make sure the data is exactly how you expect the data to be and you step out the back-end. Notice I didn&amp;rsquo;t say you step out the back-end in the end-to-end testing. Normally when I&amp;rsquo;m doing end-to-end testing, I won&amp;rsquo;t step out the back-end: I&amp;rsquo;ll write a light-weight server in the back-end that provides data the way I will consume in my front-end even if I&amp;rsquo;m not writing the back-end if I&amp;rsquo;m more concerned with the front-end.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: All right, but you don&amp;rsquo;t just load fixtures for the data, you still have a back-end server that serves the actual data. You have API endpoints in your head, right?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: I do, when I&amp;rsquo;m doing end-to-end testing. And that doesn&amp;rsquo;t mean that I&amp;rsquo;m developing a full back-end application. When I do write code, I&amp;rsquo;ll write a back-end server that just loads JSON fixtures and serves those.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: OK. To talk deeper in Angular, my experience says that everything was really good and this is maybe when I got to a confusion point myself with Angular. Everything was good when I was doing two-way binding: you don&amp;rsquo;t have to scope, controllers and all that. Even when I started doing services that was OK. I felt like I could get that but things really got complicated when I started working with directives. Was that a common experience?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Sure, so I&amp;rsquo;ll answer that in just a second. In order to give you a little bit of background information on where this enters, I teach Angular at a couple of schools here in San Francisco to real-life students and I also do corporate training; I teach large and small teams of Angular developers around the Bay Area and the United States and potentially in China later this year.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Do you know when you&amp;rsquo;re coming to China? Do you have a class already?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: I think from what I can tell, I&amp;rsquo;m speaking at &lt;a href="http://velocity.oreilly.com.cn/"&gt;China Velocity&lt;/a&gt;, it&amp;rsquo;s the O&amp;#39;Reilly conference in Beijing. I think that&amp;rsquo;s in August. It&amp;rsquo;s not quite confirmed yet so I may be in Beijing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: OK. That&amp;rsquo;s nice. When you&amp;rsquo;re in Beijing, definitely let me know. If you want to, we can do some get-together. There are a lot of developer events happening in Beijing, even major cities, so if we can hook you up with some events that would be cool.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Yeah, sounds good. So one of the most common questions that I get the most when I&amp;rsquo;m teaching. I should mention that I teach people of all ages and of all skills: both really experienced developers who were asking questions to very specific scenarios and to people who have never written code before. Universally two questions that most people are confused on are services and directives. The differences in services and what matters in that and also what is a directive and how do you build a directive. So I hope that the next sentence will help clear that up and help you. Basically, a directive itself is simply a function and it&amp;rsquo;s a function that runs on an element to augment that element. That&amp;rsquo;s it. It&amp;rsquo;s just a function. If we have slides here, I would walk you through my generic slide deck. This is a somewhat oversimplification of how the browser works and it&amp;rsquo;s also not entirely true of about what I&amp;rsquo;m about to say but that&amp;rsquo;s how I like to think about it when I explain directives. When a browser encounters an HTML tag, for instance, when it encounters an &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; tag, you can think about it like that the browser is running the h1 method. It&amp;rsquo;s saying: Oh I found an h1 method that needs to be called so I&amp;rsquo;ll run that method. A directive is kind of like a composition of that element. In that same scenario, the browser would say: Oh there&amp;rsquo;s an &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; tag. Great. I need to run the &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; tag element; and then Angular would say: Oh and there&amp;rsquo;s a directive on this element called &lt;code&gt;ng-click&lt;/code&gt; and now I need to run the function on this &lt;code&gt;ng-click&lt;/code&gt; element. So directives themselves conceptually are very simple; in practice though they can be a little bit more complex about how they work. The majority of my teaching when I do teach to live classes, I spend a lot of time on events, directives and how they work and when you use them and when you don&amp;rsquo;t use them.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Yeah, it felt like when I was building the app, when things got complicated, there wasn&amp;rsquo;t a lot of good documentation with sample apps with very complicated business logic so that I can see how they organize the app. On the high level I understood how I should do it but there were still a lot of nitty-gritties that I just couldn&amp;rsquo;t figure out myself. So I actually went to the IRC room for Angular and I was asking around. One of the guys there, he was very helpful by the way, which probably says that the framework has a very good community. He was very helpful. He basically said you should do directives for this and walked me through an example on how to do it but a lot of the things he said I just couldn&amp;rsquo;t find anywhere in the documentation. I wouldn&amp;rsquo;t have known that if he didn&amp;rsquo;t walk me through that scenario.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Sure. So actually you bring up the point of how I started working on the book. When I started with Angular, one of the things I noticed right away was that the documentation was terrible. And there was really no documentation. Even today, the official documentation is getting better but it&amp;rsquo;s still not an easy landscape. And because there was not enough documentation, the way I ended up learning Angular was by walking through the source code and looking at how things work and trying to understand that to fill in the blanks. I realized as much as I liked walking through source code, there were also a lot of people who don&amp;rsquo;t like walking through source code to learn. So the way I stumbled upon why I should write a book is because my learning of Angular was somewhat treacherous and now that writing a 600-page book and constantly updating it will definitely hammer in good practice into anyone through a couple months of writing. Now that I have that under my belt and now that I understand the framework really in depth and I teach a lot and I write a lot on it, those types of questions are getting easier and easier for me to answer and also easier and easier for others to answer due to the fact that I write and share a lot.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Yeah, I haven&amp;rsquo;t done a lot of front-end JavaScript development for the last maybe half a year to 9 month or so but I look forward to going back and seeing the best practices that are emerging from the community. Back in the days, I felt like it was a little bit chaotic and it definitely feels like every problem I was trying to solve, I constantly felt like I was asking myself: should I use services for this or maybe this is a directive or maybe I can go either way. There&amp;rsquo;re many ways to solve a problem.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Sure, it&amp;rsquo;s also a natural process too. You&amp;rsquo;re referring to community standards and best practices. That doesn&amp;rsquo;t happen overnight: if you think back to the early days of the internet there were all sorts of protocols. There were rival things, rival even TCP/IP and there was no standard way of communicating. Like SYN-ACK was not a well-understood concept back in the day. Should I wrap my packets in 64 bits or should I do in 32? It&amp;rsquo;s natural and also if you think about it from a micro level, it&amp;rsquo;s natural when you&amp;rsquo;re writing your own program, your APIs wildly changes than you were first writing your application. The longer the time goes on, those things settle down and your internal application APIs start to settle down and they don&amp;rsquo;t change as wild. The same thing can be said when you build frameworks. Now we&amp;rsquo;re kind of hitting a spot when Angular itself is mature to a point where the APIs are settling out and there were really well-understood best practices and although the framework itself is still constantly changing, it&amp;rsquo;s changing less and less from an external perspective.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Actually, I can tell you the thing I do like about Angular is the general thinking of it, just expanding the html. I think I read somewhere that says teach browser new tricks. That really makes sense. That way of thinking, packaging code and organizing code make a lot of sense.&lt;/p&gt;

&lt;p&gt;You probably get this a lot. The kind of where Angular is in the whole new generation of new JavaScript MVCs coming up nowadays like every few weeks there&amp;rsquo;s a new one. How do you see Angular compare with some other JavaScript MVCs?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Sure, I think a lot of the &amp;ldquo;new generation of MVC frameworks&amp;rdquo; because JavaScript itself is taking off as a new language, which came out 5 or 6 years ago. So somewhat legitimized JavaScript itself as a language and it become the more JavaScript is used on the server side the more we&amp;rsquo;re seeing this evolution of JavaScript itself. I think with the advent of ES6, which is a completely new version of JavaScript and it&amp;rsquo;s awesome. By the way, if you haven&amp;rsquo;t used it or a least haven&amp;rsquo;t explored it, it promises to make a lot of things easier and more standard.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: It&amp;rsquo;s Chrome that does not support it yet right? I think FireFox does.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: &lt;a href="https://www.google.ca/intl/en/chrome/browser/canary.html"&gt;Chrome Canary&lt;/a&gt; does. Chrome itself, if you enable the experimental features it does. The latest version of Firefox does support ES6. And of course if you use bleeding edge &lt;a href="http://nodejs.org/"&gt;Node&lt;/a&gt; it supports ES6 too. Even if you&amp;rsquo;re not using the bleeding edge version of Node you can use the ES6 flags and enable ES6 when you&amp;rsquo;re running.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Yeah, there&amp;rsquo;s a lot of exciting things in there. &lt;code&gt;Object.observe&lt;/code&gt;, is it ES6 or ES7? I think it&amp;rsquo;s 6, right?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: I believe that&amp;rsquo;s ES6. It may have been pushed to ES7 but I would be really surprised if it did. I&amp;rsquo;m pretty sure it&amp;rsquo;s still ES6. Getting back to the point, with the changing landscape of JavaScript, it&amp;rsquo;s approaching us pretty quickly and with more eyes on JavaScript, we&amp;rsquo;re getting a lot of different ways to view how we build front-end client-side JavaScript applications and you&amp;rsquo;re getting also the same thing from the back-end perspective but it&amp;rsquo;s very different. In terms of how does this reflect what frameworks we should use to build our client-side applications, really I think a lot of that depends on what you&amp;rsquo;re doing and what type of application. I think there is both matter of preference and also matter of community and where they stand in terms of their longevity. I think Angular itself has Google sponsoring it. Google has hundreds of projects that depend on Angular and depend on the Angular team internally so Google is paying for some really awesome developers to build Angular itself and to continue to advance it. They think when you look at that in comparison to a lot of other frameworks, there&amp;rsquo;s a lot of other frameworks that are just out there because an author decided that they like how it looks or because a group of people got behind a single project and use their off-time to develop the framework and I think if you&amp;rsquo;re building something in a professional perspective, at least for me it&amp;rsquo;s really important that what I&amp;rsquo;m building won&amp;rsquo;t just go away because the author decided he didn&amp;rsquo;t like writing it anymore or the community slowed down because the author was less involved or there is no sponsoring the framework to be developed. So I constantly get asked the question: should I use Ember? should I use Knockout or should I use Angular? My generic answer for that is: what are you building? If you&amp;rsquo;re not building an action RPG game in the browser, let&amp;rsquo;s say use Angular. The conventions are really well set up and the community is incredibly vibrant. Again it&amp;rsquo;s backed by one of the world&amp;rsquo;s top internet companies with some of the smartest JavaScript minds available today working on it and there&amp;rsquo;s just a gigantic explosion of the interests in Angular so it&amp;rsquo;s not going away; it&amp;rsquo;s only getting better.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: It&amp;rsquo;s interesting you mentioned Ember because as far as I know when you build an Ember app the premise is you want to move all the logic to the front-end and leave your back-end as a pipe to the database. Is Angular the same way or is it less demanding in a way?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: I have not built an Angular app that depends on a server-side rendering, all my Angular apps in production, both my apps and my clients&amp;#39;. I used to contract Angular development are all deployed in &lt;a href="https://aws.amazon.com/"&gt;AWS&lt;/a&gt;, on &lt;a href="http://aws.amazon.com/s3/"&gt;S3&lt;/a&gt; so there is no server backing it. They are simple just files and those files load up and they talk to a back-end and that back-end is simply a pipe to a database or a couple of databases depending on the application. So that&amp;rsquo;s the long answer. The short answer is yes, it has the exact premise if you want it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: I kind of feel that way already because I started just with coding Angular into a Rails application and I then kept asking myself: should I put it in the server-side or on the front-end and it&amp;rsquo;s a lot of conflict. Maybe it&amp;rsquo;s just way easier if I decided to move to the client-side and just leave the server to do very simple things.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Yes, again it depends on what you&amp;rsquo;re building. If you&amp;rsquo;re building an application that needs incredibly tight security, you probably want that served by a back-end, at least of some sort, even a light-weight back-end is OK.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Speaking to that, I think maybe that can be an advantage to Angular as well because I don&amp;rsquo;t think I could have done that with Ember. For Angular I can just for this part of the UI. If I want to put an Angular in, I can surgically enhance one area whereas Ember tries to take over my routes and URLs and all that. I have less room to negotiate with the framework.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Sure, I should mention that if your preference is Ember and this is not just you Kevin, but anyone. If your preference is Ember, use Ember. If you&amp;rsquo;re going to be building a production level application, do use the best tools that you are comfortable with to get you moving faster rather than just use the tool because it&amp;rsquo;s hot. I can say that Ember itself pre-1.0 was a really terrible framework. I&amp;rsquo;m sorry Ember guys. But post-1.0 they took a lot of ideas that the Angular team had built and integrated those into the Ember framework. It&amp;rsquo;s actually a relatively decent framework. I mean I don&amp;rsquo;t like writing in Ember because I feel like there&amp;rsquo;s a lot that I have to do in order to maintain my Ember application and make it a nice experience for me as a developer. One of the reasons I really enjoy Angular is I don&amp;rsquo;t have to do that. I can communicate and build my app super fast on Angular whereas Ember takes a little bit different cognitive overhead to develop some nice apps. But again that&amp;rsquo;s me, if you like writing Ember and you&amp;rsquo;re writing a production-level application and you need that production-level application, don&amp;rsquo;t fight with the framework, fight to make the best experience for your users. I can&amp;rsquo;t say if you&amp;rsquo;re not doing that and you&amp;rsquo;re not in the phase where you&amp;rsquo;re developing your application for production level, definitely explore Angular though because that will make you a much faster to rapidly build rich interactive experiences for you users.&lt;/p&gt;

&lt;h4&gt;Part 2: Full stack developer&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: So let&amp;rsquo;s change the topic a little bit. I noticed that your company is &lt;a href="http://www.fullstack.io/"&gt;Fullstack.io&lt;/a&gt; and there&amp;rsquo;s this emergence of concept of full-stack developer. How do you think about that and obviously you guys are invested in this idea. Was that mostly because of the popularity of JavaScript for the last 5 years maybe? Why the concept now is becoming so popular and you see all the hiring requirements and everybody wants full-stack developers?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Sure, this exists because of the recruiters of the world are constantly looking for what&amp;rsquo;s the next thing. Recruiters run on finding developers for companies and constantly want the best developers. So in the recruiting world you get these buzzwords that pop up all the time: data scientists for a little while, full-stack developers kind of right now, cloud engineers before, server-side engineers before, rockstars used to be a thing. In terms of what full-stack means itself, when you&amp;rsquo;re talking about web application developers, full-stack itself simply means you can write server-side code and front-end code and I attribute the growth of the &amp;ldquo;full-stack developer&amp;rdquo; due to the fact that Node came out and allowed developers who were already comfortable writing front-end code to become comfortable writing server-side code.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Yea it definitely felt that way because that&amp;rsquo;s about the time when this concept started to emerge.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Yea. So for &lt;a href="http://www.fullstack.io/"&gt;Fullstack&lt;/a&gt;, we named ourselves Fullstack because at the time I was doing some hardware contracting and the fact that I was doing hardware contracting as well as writing JavaScript kind of land itself to the name.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Oh, you&amp;rsquo;re doing JavaScript and hardware? What type of hardware?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: That&amp;rsquo;s one of the unique things about our company itself. A quick aside is we have experience that goes from low-level embedded hardware all the way up to the stack.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: That&amp;rsquo;s really the full stack!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: It&amp;rsquo;s a full stack. If you can build the hardware and you can build the OS and you can write the browser-side that will communicate, that&amp;rsquo;s pretty full-stack. We were doing a lot of &lt;a href="http://www.raspberrypi.org/"&gt;Raspberry Pi&lt;/a&gt; work back to the day and embedded computing to answer your question.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: So this really predates the modern-day concept of full-stack developer, not just you can write server code and JavaScript code.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Yeah, it&amp;rsquo;s somewhat unfortunate that full stack itself is different meaning than we like to share it as.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: That&amp;rsquo;s interesting because do you guys do web app consulting nowadays?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: We used to. We&amp;rsquo;ve done a lot less consulting right now. One of my passions is teaching and the more I&amp;rsquo;m contracting, the less I can teach, the less I can write to teach, the less I can interact with students so these days we&amp;rsquo;re not doing very much contracting, at least for the time being.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: OK. I guess what I wanted to check with you is what&amp;rsquo;s your favourite framework on the back end? Obvious Angular is what you want to use on the front end. Do you see yourself reaching for node more or still Rails?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Good question. I don&amp;rsquo;t get asked that question all that often. Depends on what I&amp;rsquo;m doing. So these days if I just want to get an application up and I want to get it out I&amp;rsquo;ll use Rails. I&amp;rsquo;ll use Rails strictly as an API server.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: &lt;a href="https://github.com/rails-api/rails-api"&gt;Rails::API&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: I don&amp;rsquo;t use Rails::API although Rails::API is much faster than out-of-box Rails. Last time I checked, they weren&amp;rsquo;t compatible with Rails 4 so I didn&amp;rsquo;t use them but they&amp;rsquo;re probably compatible now. My two favourite languages right now that I really enjoy writing in is &lt;a href="http://golang.org/"&gt;Go Lang&lt;/a&gt;, which comes out of Google, and &lt;a href="http://clojure.org/"&gt;Clojure&lt;/a&gt;. So anytime that I can find an excuse to write a Go Lang server or a Clojure server, I definitely go for it. Again it depends on what I&amp;rsquo;m writing. If I&amp;rsquo;m writing something really heavy in statistical application or I&amp;rsquo;m doing anything with machine learning or big data I&amp;rsquo;ll tend to use Clojure and if I&amp;rsquo;m doing for fast response times I&amp;rsquo;ll use Go.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Yeah, that&amp;rsquo;s interesting because I looked at Go, I haven&amp;rsquo;t looked at Clojure yet, it feels like it&amp;rsquo;s very low level. So maybe that goes well with Angular, the rich JavaScript MVC part where you just have a pipe to the database and just move the logic to the front-end. Maybe that&amp;rsquo;s a good combination.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Yeah, I try to make my server-side as dumb as it possibly can be and my client-side as smart as it possibly can be. Obviously there are some places that breaks down: if you have security concerns you can&amp;rsquo;t put your security on the client-side because it&amp;rsquo;s just exposed to the world. In that case, you&amp;rsquo;ll have a back-end to store user data and stuff like that.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: I&amp;rsquo;m surprised you did not mention &lt;a href="http://www.erlang.org/"&gt;Erlang&lt;/a&gt; because you did say in the beginning that you did some Erlang projects before so how come no luck for Erlang?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Actually, I still love Erlang. Erlang is very good for very specific use cases. The use case that I mentioned before was for a open-source clone of Heroku. It&amp;rsquo;s super good for processing, routing and distributed computing. So as much as I love Erlang and Erlang itself is fantastic, I like writing in Erlang, some people don&amp;rsquo;t. I really like writing in it. I haven&amp;rsquo;t found a good use case for me to have an excuse to work on Erlang in a while. I do love it though. If you haven&amp;rsquo;t used it, you should definitely look at it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: OK, but you definitely did not mention Node.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: I do like Node. Node is kind of a my competitor to Rails. Things that I like about Node or things I don&amp;rsquo;t like about Rails, I&amp;rsquo;ll go and use Node. I really like writing small Node applications. So if you&amp;rsquo;re doing SOA style applications, as opposed to using Rails, Node is really good for that. You can have a server-side that&amp;rsquo;s just dedicated to user and authorization and authentication and that can be its own SOA application. And node has fantastic support for that through something called &lt;a href="http://passportjs.org/"&gt;Passport&lt;/a&gt;. Sometimes I get really annoyed with Node because JavaScript itself can be kind of an ugly language and if you&amp;rsquo;re not careful with how you write your code or you don&amp;rsquo;t use promises and you use a lot of callbacks, Node itself can be really hairy.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Yeah, but you did mention promise. I think that&amp;rsquo;s kind of a way to get out of the callback hell.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Yeah, promises are awesome.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: You talked about using Node in a SOA type of context. I guess the opposite of that is a large application, a lot of workflowy logic. That&amp;rsquo;s when you don&amp;rsquo;t want to use Node. Is that right?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: If we&amp;rsquo;re talking about me, yeah. Node itself is a competitor to Rails in my opinion. So if you enjoy writing Node in that large application, you definitely can use Node to do that. My particular preference is to it for small projects.&lt;/p&gt;

&lt;h4&gt;Part 3: Book Authoring&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: OK. Let&amp;rsquo;s change topics again. You recently wrote 3 books. I want to talk about the book-writing process. So maybe you can walk me through. Maybe you can start with why you wanted to write these books and what you went through the process of actually writing it?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Sure, we can open that can of worms. As I mentioned before, I was learning Angular by reading source and scouring the web for as much documentation as I could, I realized there was not enough out there to support what I was looking for. So I identified this as an area of opportunity, where I could help others learn Angular from my experience of learning it myself so when I first started writing the book, I had this idea that I would write kind of a mini beginner&amp;rsquo;s guide to Angular and when I say mini it&amp;rsquo;s anywhere between 50 to 100, maybe pushing 200 pages. I thought it would definitely not break 200 pages. One of the things I found as I was writing the beginner&amp;rsquo;s guide is that the beginner&amp;rsquo;s guide itself would help get started on Angular, it&amp;rsquo;ll help get over the hump of learning Angular, but that&amp;rsquo;s a really arbitrary limitation. What I found was that by writing a mini book, I would only be helping a very small subset of people who either like to read the documentation or my beginner&amp;rsquo;s guide. So one of the things early on what I started to do is I started writing this blog and it&amp;rsquo;s running now and we get hundreds and thousands of visits. It&amp;rsquo;s called &lt;a href="http://www.ng-newsletter.com/"&gt;ng-newsletter&lt;/a&gt; and I focused on the beginner&amp;rsquo;s guide to that. Our first series of posts were the beginner&amp;rsquo;s guide to Angular that was the beginning of the book. If you look at the comments in any of the first 7 articles or so, you&amp;rsquo;ll see that people are saying yes but what about this, what about that and because I was getting so many of those types of comments, I started teaching by that point after I&amp;rsquo;ve written those initial posts. I got more questions about like what&amp;rsquo;s next, so that kind of started leading me to continue to write this book and continue to put more thought into the full design of the book, not just beginner&amp;rsquo;s guide, but professional&amp;rsquo;s guide to writing Angular applications.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: So at that point, you know you wanted to write a book, not just newsletters or blogs?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Yep. So I have also recently left AT&amp;amp;T, and after that I was wanting to deploy this application and I kind of found that my interest in teaching overtook my interest in building and deploying and running this other application so I came to this conclusion that I really wanted to simply just write the book and I was still continuing to develop past that as well.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: So this was mid-end last year?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Yes, I started writing in May but not seriously. That was when I was starting to write the Angular cook book which is unreleased because I moved on to write &lt;a href="https://www.ng-book.com/"&gt;ng-book&lt;/a&gt; but I can still come back to that. I started writing in May, not really dedicated to it and I really got dedicated in July and just started writing and writing and writing and I can tell you, from personal experience, if you&amp;rsquo;re thinking about writing a book, consider really hard. It&amp;rsquo;s hard especially when you get to the point where you&amp;rsquo;re approaching the end of the book and you have to go back and clean up a bunch of things. It&amp;rsquo;s hard. It&amp;rsquo;s not an easy process and you also have to sit down every single day and write something. It got to the point where I was writing about 1000 words a day and that&amp;rsquo;s a couple hours worth of work. So if you&amp;rsquo;re not writing for a couple hours every single day&amp;hellip;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Is that kind of a hack, a way to keep you going? You&amp;rsquo;ll  keep the momentum like i just need to get today&amp;rsquo;s share done?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Yeah, there was a professor out of Stanford, &lt;a href="http://www.bjfogg.com/"&gt;BJ Fogg&lt;/a&gt;, who wrote &lt;a href="http://tinyhabits.com/"&gt;Tiny Habit&lt;/a&gt;. Essentially what he says is set up triggers for yourself such that you can create a new habit when you encounter that trigger. For instance, his example was as you walk into the bathroom and brush your teeth when you put your toothbrush down into the toothbrush holder and hear the ding, then pick up the floss. If you set it up enough time, even if you don&amp;rsquo;t floss but you pick up the floss, it&amp;rsquo;ll start to become second nature where you hear that ding, you pick up the floss, oh now you find yourself flossing your teeth simply because you set up a habit for yourself. It also says reward yourself with that too. So even if you pick up the floss, go have a cookie (even though that&amp;rsquo;s kind of the opposite). So in order to actually get this book done, I had to set up triggers for myself like that: as soon as I sat down at my computer and I opened up my email client, I would open up my notes for what I needed to write during that day and fill that out and then go back to my email client so that by the time that I was ready to start writing, I had already written the outline for what I was going to write later that day and because I had set this habit up every single time, every single day I would open up my email client, which could happen multiple times a day, I would find myself getting more and more excited and more and more ready to write the sections that I was going to be writing. So yes, it&amp;rsquo;s absolutely a life hack to get myself to write a 600-page book.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: That sounds very intimidating. We&amp;rsquo;re in the process of writing some very small books and even that is (hard). I just couldn&amp;rsquo;t imagine myself writing 600 books.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Also 600 books would be a lot of work.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Did you plan to write that many?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: No way! I thought I would write a 100-page book and I thought that was a lot.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: So yeah, other than forcing yourself to start writing two hours every day, what are the other challenges while writing this book?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: I think one of the biggest parts was build up the audience, build up the people who would eventually become customers of the book. I wasn&amp;rsquo;t just writing the book, I was also writing ng-newsletters, I was also talking in events and I was also doing guest writing for other blogs and writing newspaper/magazine articles and etc. I was also writing code and contributing back to Angular and also I had a day job. At that time I was consulting. Most of the challenges was even just finding that time.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: So you talked about building audiences. Are you talking about going to events to talk to people so people know who you are and they know that you&amp;rsquo;re writing a book so maybe they&amp;rsquo;ll go on your pre-launch email list? Is that the general process?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: When I talk to people in person that&amp;rsquo;s more of building up a network of friends. When I&amp;rsquo;m talking about building an audience, I spend an extraordinary amount of time crafting what I write for ng-newsletter. I write a lot for ng-newsletter. Just the latest &lt;a href="http://www.ng-newsletter.com/posts/building-2048-in-angularjs.html"&gt;post&lt;/a&gt; on ng-newsletter is about building a game. It&amp;rsquo;s about building 2048. In that I covered test-driven development; I covered animation; I covered CSS transformations; I covered end-to-end testing; I covered some light-weight game development topics. That was a gigantic post. I think if you print it out it&amp;rsquo;s something like 22 or 25 pages. When I talk about building an audience, what I mean is trying to spend as much time as I can afford to spend building up posts to let people know on the Internet who I am. That&amp;rsquo;s pretty much where we started. The ng-newsletter list itself has about 2,500 people at this point and that&amp;rsquo;s because I still spend so much time building up and writing those posts. So building an audience is hard. That&amp;rsquo;s probably the hardest part about being an independent author and independent business owner.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Yeah, I can imagine if you didn&amp;rsquo;t have the audience when you launched the book, right away you can&amp;rsquo;t have people interested in buying, then it&amp;rsquo;ll be kind of a depressing experience like hey I launched a book and nobody knows.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Yeah, you want to set yourself out if you&amp;rsquo;re thinking about running your business or if you&amp;rsquo;re thinking about writing a book. A quick aside, I actually don&amp;rsquo;t believe in stealth start-ups. I think if you&amp;rsquo;re doing something stealth, you&amp;rsquo;re losing audiences, you&amp;rsquo;re losing potential customers. If your company calls itself a stealth start-up, then you&amp;rsquo;re cutting off your top line. But back into that, if you&amp;rsquo;re thinking about writing or a book or launching some software, think about how you can communicate that to the rest of the world, you&amp;rsquo;ll have to spend (time building an audience). I spent probably 60% of the time when I was writing this book on writing ng-newsletter articles.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: OK, so the majority of time you spent on making yourself known and making free educational articles, resources that help contribute back to the framework. So the popularity of the book is a result of that, right? The book itself is great but that&amp;rsquo;s not enough.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Sure, you can have the best artwork in the world or the best song in the world but if nobody hears it then it can&amp;rsquo;t be the best song in the world. It&amp;rsquo;s definitely not enough to have great software or to have great words on the page. One of the reasons why you would go to a publisher in the first place is distribution. You write a book for O&amp;#39;Rielly because O&amp;#39;rielly does the legwork of distributing your book and O&amp;#39;rielly has tens of thousands if not hundreds of thousands of people on email lists and event pages and personal connections with libraries and bookstores and other distributors like that. The downside of that is almost everything other than distribution you can do for yourself if you&amp;rsquo;re writing a book and you can self-publish, especially with all the tools today.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: What tools did you use?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: There&amp;rsquo;s a bunch. I have a home-brewed, which I wouldn&amp;rsquo;t do in the future, but I&amp;rsquo;ll be open-sourcing it. It should already be open-sourced but if it&amp;rsquo;s not, I&amp;rsquo;ll open source it. It&amp;rsquo;s called Pandoc so I have a workflow that&amp;rsquo;s built off Pandoc when writing my ng-book. Also my other mini books are written using a combination of Pandoc and Markdown or Latex or even I have a couple of mini books written in ASCII doc. But it all works through my tool which is just a workflow chain around Pandoc. You can also use &lt;a href="https://leanpub.com/"&gt;Leanpub&lt;/a&gt;. Leanpub is awesome. They have their own sales distribution channel, they have their own email list  and all that fun stuff. Also one of the really nice things about Leanpub is that they allow you to pre-sale the book. That&amp;rsquo;s another thing. As I was writing writing the book, I didn&amp;rsquo;t mention before is I opened it up for pre-sale very early on when I was at about 200 pages and that helped immensely. One of the benefits that I found that I got when I was pre-releasing was I got a lot of feedback on the book really early on so it allowed me to define what I needed to write more on or what I needed to write less on and it really helped that everyone who bought the pre-released version of the book was very sympathetic to the fact that I was working as hard as I could at the time to write the book so I got less angry comments early on than I would get later because the book wasn&amp;rsquo;t finished or something was incorrect or I have misspelling here and pre-releasing helped me to find that. Still to this day, I get a lot of help from the community in part because I make it known that I&amp;rsquo;m an independent book seller and I work really hard on making sure that the books and the materials that I produce and sell to the community are the best that they can possibly find and because my customers know that, I get a lot of help. When people find bugs or misspellings or weird grammatical sentences they&amp;rsquo;ll help and they&amp;rsquo;ll contribute back to the book and it makes it better for everybody. That&amp;rsquo;s really awesome. So definitely pre-release if you&amp;rsquo;re thinking about writing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Yeah, that almost feels like a &lt;a href="http://theleanstartup.com/"&gt;lean startup&lt;/a&gt; idea. You also want to just release it and see how much interest you&amp;rsquo;re gonna get. When you pre-sale the book, did you actually take the emails and actually charged their credit cards at that point?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Yeah, I did. In order to deliver the book, I had to have your email so I could actually send you the book and that helped with the list itself, especially when we have updates to the book cause we know who&amp;rsquo;s bought the book and we can send email updates. Another thing that&amp;rsquo;s really nice about having an email list is we were kind of on the dawn of launching our &lt;a href="http://www.fullstackedu.com/"&gt;video site&lt;/a&gt; and we have anyone who&amp;rsquo;s bought the book we have their emails and we&amp;rsquo;re going to be sending some pretty heavy discounts to our email list of people who have supported the book to our video site. So that when we launch our video site, we have this list of supporters that we benefit from because we can get feedback. This is very similar to pre-launching the book, we can get immediate feedback about the videos and the video site itself and we also can launch it to friendly people and also people who have shown interest in what we&amp;rsquo;re producing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Speaking of the videos, is this a video site for the book or is it new material?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: It&amp;rsquo;s new material. We&amp;rsquo;re likely going to move our existing ng-book stuff onto it. This may or may not happen. I can&amp;rsquo;t speak to that right now beyond we&amp;rsquo;re thinking about moving people over to it but that&amp;rsquo;s just an idea.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: But I do notice that you have a website just for the book. Maybe our listeners are not aware of this. On &lt;a href="https://www.ng-book.com/"&gt;ng-book.com&lt;/a&gt;, I noticed that you have 3 different packages: it&amp;rsquo;s not just a book. You have one package of the book with source code and you have another package of book, source code, video, sample app and a team license. I don&amp;rsquo;t see this a lot from book authors. Is this the plan from the beginning or you just felt like doing more videos and giving more resources.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: That&amp;rsquo;s a good question. There&amp;rsquo;s a company called PeepCode that used to exist before a company called &lt;a href="http://pluralsight.com/"&gt;Pluralsight&lt;/a&gt; bought them. I was shooting the Angular video for them in June of last year. That&amp;rsquo;s why it took me until July to get serious about writing the book cause I was shooting a screencast on Angular for PeepCode although I was still writing ng-newsletter. I had shot about 3 hours worth of screencasts for PeepCode and PeepCode got bought by Pluralsight and I talked to the Pluralsight and went through their video author workflow and decided that it wasn&amp;rsquo;t really the best deal for me so I pulled my video from Pluralsight which hadn&amp;rsquo;t been launched yet so I had this 3-hour video that I worked really hard on and crafted really hard too that was kind of sitting around. I launched the book with a single package but I realized I had this video sitting around and I had a bunch of sample apps that I&amp;rsquo;ve written to do teaching to teach my students about Angular so it kind of just dawned on me and through discussion with my co-founder, that should definitely be a part of another package so I went through the work of cleaning things up. I wrote a secondary sample book that went along with it. I wrote an in-depth discussion about how one of the sample apps works and wrote another 100 pages or so about and packaged everything up into the second package. That&amp;rsquo;s how the second package came about.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: It definitely makes sense because if I&amp;rsquo;m committed to buying the book, I&amp;rsquo;m probably committed to Angular then I definitely want to get all the learning materials and it&amp;rsquo;s also coming from you that goes with the book. I think that&amp;rsquo;s a pretty good deal.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Thank you for the compliments and to continue on that line of thought, one of the things we found is that people were buying the second package because they heard so much good feedback about the video which itself it&amp;rsquo;s a 3-hour-long screencast to Angular. Because we&amp;rsquo;re getting such good feedback about the video, one of the things that we realize is a lot of the video resources out there right now for Angular are micro. They lose context: when you know how to build a router, that&amp;rsquo;s great, but how does that fit in with the rest of your application. One of the most constant questions I get from people who have even watched another site called &lt;a href="https://egghead.io/"&gt;Egghead&lt;/a&gt; . They&amp;rsquo;re really awesome but they&amp;rsquo;re not really great for learning Angular. They&amp;rsquo;re really great for learning concepts of Angular. It&amp;rsquo;s called &lt;a href="http://fullstackedu.com/"&gt;fullstackedu.com&lt;/a&gt; by the way. One of the great pitches to fullstackedu.com is that it&amp;rsquo;s not a concept learning site, it&amp;rsquo;s a professional learning site to teach the full stack of here&amp;rsquo;s how everything works. We have potentially a couple different videos coming out. I&amp;rsquo;m doing one on using Angular to build mobile apps. We&amp;rsquo;re launching with one on Angular on Rails, the right way to include those two. We have potentially an author, a UX guy from Apple who&amp;rsquo;ll be shooting the guide to doing UX development. It&amp;rsquo;s possible that we&amp;rsquo;ll have an expert in security who&amp;rsquo;s contracted by the Department of Defense constantly to do a security training course. We have a lot of what we&amp;rsquo;d like to call them expert-level screencasts going into the site and all that came out of the feedback that we have a lot of people who really like the long-form video.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Is this launched yet?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: You can go to the site right now. It&amp;rsquo;s a sign-up page. We&amp;rsquo;re launching in beta next week for early audience members, trying to get some feedback from them and a couple weeks later we&amp;rsquo;ll do a general launch and hopefully by then we&amp;rsquo;ll have those two videos ready to go. We definitely have one ready to go right now. We&amp;rsquo;re just building up the touring around the actual site itself. I believe we&amp;rsquo;ll do a video on how we built fullstackedu.com so if you&amp;rsquo;re interested in learning how to build a system that accepts payments with users. That one was written in Rails along with a really advanced client-side application. That&amp;rsquo;ll be available on fullstackedu.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Cool. So that&amp;rsquo;ll be a subscription service?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: We&amp;rsquo;re not entirely sure about what the pricing looks like quite yet. We&amp;rsquo;re launching as a subscription service but we have the capability to do both subscription and non-subscription. We&amp;rsquo;ll play around with our audience. This is one of the reasons, we&amp;rsquo;re going to play around with what our audience likes the most. We&amp;rsquo;ve done some early UX testing and it seems like mostly people like subscription v.s. one-time purchases.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: OK. I also want to talk about how the book writing experience started from last May to now helped you professionally.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: I&amp;rsquo;m so glad you asked that question. If I can enumerate a little bit of what it&amp;rsquo;s given me: Writing a book has given me publicity; it&amp;rsquo;s made my name known; it&amp;rsquo;s given me legitimacy that I can teach; It&amp;rsquo;s introduced me, in fact before last May I didn&amp;rsquo;t really do teaching. I only found that I had a passion for teaching after I started teaching and that was because I was writing a book at the time and I uncovered that I really enjoyed doing it. Now I speak at conferences, I&amp;rsquo;m sought out as an expert in Angular. You guys found me so I&amp;rsquo;m speaking on this podcast because I wrote a book on Angular. I advice for startups because I wrote a book. My professional career is as vibrant as it is right now because I did the work of writing a book and building audience and really dedicated myself to write the book and also to my audience. One of the really nice things that it&amp;rsquo;s done is also the number of recruiters and job offers that I get is skyrocketed. It has also helped me learn how to build a business. It&amp;rsquo;s connected me to really smart people. I&amp;rsquo;ve encountered really upset early mornings when I get angry emails and without the process of writing the book, I would freak out about that. I would not have the experience that I have today to learn how to deal with customer development the way that I have and this is coming from someone who&amp;rsquo;s done 21 years of professional software development. My career explosion has happened simply because I wrote a book. I don&amp;rsquo;t want to downplay the amount of work that it took but writing the book itself made me an expert in Angular and made me a recognized expert in the world.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: That&amp;rsquo;s amazing. Was it also because when you started writing the book, it was still quite new and there wasn&amp;rsquo;t a lot of books or learning materials on the subject? In other words, if somebody else is to write a book today, should they look at those areas to start instead of writing a book on a highly-covered subject?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: That&amp;rsquo;s a good question. I&amp;rsquo;ll answer that in 2 ways. First one is if you&amp;rsquo;re going to write a book, regardless of what topic it&amp;rsquo;s on, I&amp;rsquo;d recommend you focus on building the audience. The reason I say that is because you&amp;rsquo;ll find, as you&amp;rsquo;re writing a book or the software that you&amp;rsquo;re going to release, that your audience grows or doesn&amp;rsquo;t grow, are they communicative or are they not communicative, are they interested in paying you or are they not interested in paying you and that&amp;rsquo;ll help inform if the subject you&amp;rsquo;re writing on is important. I know some very successful people who have a couple books on PHP and PHP has been around for a long, long time and their books are incredibly successful. So it&amp;rsquo;s not necessarily about the topic. The topic itself, because I wrote on Angular, I got really lucky in the fact that Angular was not very well-covered when I started writing this book. I got lucky in the fact that I became an expert in Angular and one of the early experts in Angular. The fact that I got lucky in the sense that I was writing on the topic that didn&amp;rsquo;t have a lot of other people writing to it, but that doesn&amp;rsquo;t mean if I was writing a book on PHP that I would have any less success or at least I don&amp;rsquo;t believe that. So if you happen to be a particular expert on PHP, definitely write on PHP but focus on building your audience and focus on making sure that what you&amp;rsquo;re writing on is of interest to that audience.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: That&amp;rsquo;s interesting because I would have thought the opposite. I would have thought you got to be early on the ship and make a name for yourself. For instance, I&amp;rsquo;m more involved in the Ruby on Rails community, it feels like in general this area is very well-covered. There are a lot of good tutorials and books in this area so it&amp;rsquo;ll be difficult to carve out a new niche.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Right, one of the unique things about Rails in comparison to Angular, one of the advantages it has is in fact it has this huge audience of professionals working in Rails. So the fact that you have this huge audience of people means there&amp;rsquo;s a plethora of different interests within the Rails community. So you get all these different niches about types of people that would be interested so if you&amp;rsquo;re writing a book on Rails for designers for instance, that&amp;rsquo;s not a well-covered area of the Rails community. How does a designer pick up Rails or how do you think about Rails from a designer&amp;rsquo;s perspective, that type of thing. The other thing is that if you&amp;rsquo;re writing about a well-covered topic, despite the fact that all these other books exist, there might not be an audience for all those other books. Like we just said, you could have the best song ever written in the whole world but if no one hears it then who cares? I did a look on Amazon for the number of Rails books and there&amp;rsquo;s a lot of them. I&amp;rsquo;ll be willing to bet a lot of them go unread and a lot of them don&amp;rsquo;t have a lot of readers and people who would potentially read your book if you&amp;rsquo;re writing a book in Rails if you spend the time to build your audience and get a growing list, then you can have just as much success in terms of popularity than if you&amp;rsquo;re writing in a space that&amp;rsquo;s relatively uncovered. I just happened to be lucky that I found a field and started writing in it and that space is relatively uncovered and that didn&amp;rsquo;t have that many people although it&amp;rsquo;s growing now.&lt;/p&gt;

&lt;h4&gt;Part 4: Share Picks&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Yeah, so what I got out of this is definitely spend a lot of time building the audience, maybe spend more time doing that, making yourself known than just focus on the technical writing. I think that&amp;rsquo;s the advice every aspiring author can take.&lt;/p&gt;

&lt;p&gt;OK, Ari. That&amp;rsquo;s all the questions I want to talk about today. In the end of the interview, typically we ask the guests to share some picks. So anything that you find fun, cool, or interesting that you want to share with us?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Sure. Can I share some software? The &lt;a href="http://www.alfredapp.com/"&gt;Alfred app&lt;/a&gt; is probably my favourite piece of software that&amp;rsquo;s made me more productive than any other piece of software ever.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Did you buy addon packages?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: I did.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: You gotta tell me which ones you used cause I&amp;rsquo;ve been looking for those. I think I have the &lt;a href="https://agilebits.com/onepassword"&gt;1Password&lt;/a&gt; one.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Oh, the second pick I was gonna say is definitely use 1Password. It&amp;rsquo;s awesome. I no longer have to memorize my really difficult passwords. I use an algorithm when I make passwords by the way based on the site that I&amp;rsquo;m on but 1Password has made that way easier and I no longer do that.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: You made your own algorithm for passwords for websites? Can you share that supposing you don&amp;rsquo;t use it any more, so maybe it doesn&amp;rsquo;t matter if you share it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Sure, I&amp;rsquo;ll write a post on it and I&amp;rsquo;ll ping you so you can let your audience know. Other things, the &lt;a href="http://golang.org/"&gt;Go Lang&lt;/a&gt; is awesome. It&amp;rsquo;s super fun to write in. So if you haven&amp;rsquo;t written in Go Lang, if you like C and low level languages, Go Lang is super awesome. And if you&amp;rsquo;ve never ridden a scooter before, I rode a scooter for the first time a couple weeks ago and it&amp;rsquo;s super fun and now I&amp;rsquo;m addicted so scooter is my last pick.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: Is that like a &lt;a href="http://www.segway.com/"&gt;Segway&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: No, it&amp;rsquo;s like a low power motorcycle. It&amp;rsquo;s not technical.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: How fast does it go?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: I think the top speed is 27 mph. Super slow but it&amp;rsquo;s still super fun. It also makes for a really good date.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: My pick here today is a software tool called &lt;a href="https://www.rogueamoeba.com/audiohijackpro/"&gt;AudioHijackPro&lt;/a&gt;. It&amp;rsquo;s the tool I&amp;rsquo;m using right now to record this conversation. We used to use a combination of several things, LineIn, you&amp;rsquo;ll have to use GarageBand to record, it was pretty cumbersome but this just took all the pain out of that so I&amp;rsquo;m pretty happy with this.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: All right, Ari. Thanks for coming and it&amp;rsquo;s definitely very fun to talk with you today. Let me know when you go to Beijing and I&amp;rsquo;ll see what we can do. We may set a meetup together for you.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Awesome. Thanks. This is super fun and keep on writing code!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kevin&lt;/strong&gt;: All right. Bye!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ari&lt;/strong&gt;: Bye!&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;span class="footnotes"&gt;
  再次感谢&lt;a href="http://weibo.com/wuyicun"&gt;@吴怡村&lt;/a&gt;对于本期节目音频的整理。
&lt;/span&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>和 Jing 聊聊 Qubit 的产品和技术栈</title>
    <link rel="alternate" href="/2014/05/04/teahour-50-with-jing.html"/>
    <id>/2014/05/04/teahour-50-with-jing.html</id>
    <published>2014-05-04T04:00:00Z</published>
    <updated>2014-05-04T04:00:00Z</updated>
    <author>
      <name>叶玎玎</name>
    </author>
    <summary type="html">&lt;blockquote&gt;
  目前 Teahour 的网站不适合放文本，需要重新设计，暂时先放我自己博客上。
&lt;/blockquote&gt;

&lt;p&gt;本文是 Teahour 第 50 期 &lt;a href="http://teahour.fm/2014/04/08/interview-with-dong-jing.html"&gt;『和Qubit的工程师聊聊A/B testing, Node 和 Ruby』&lt;/a&gt; 的录音文本，欢迎大家订阅 Teahour，iTunes URL 是 &lt;a href="http://itunes.apple.com/cn/podcast/teahour.fm/id608387170?l=en"&gt;http://itunes.apple.com/cn/podcast/teahour.fm/id608387170?l=en&lt;/a&gt;。Android 用户可以使用 &lt;a href="http://m.coolapk.com/apk/de.danoeh.antennapod"&gt;AntennaPod&lt;/a&gt; 来订阅。同时，欢迎加 Teahour 好友，&lt;a href="http://weibo.com/teahourfm"&gt;微博&lt;/a&gt;和 &lt;a href="https://twitter.com/teahourfm"&gt;Twitter&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;audio controls name="media"&gt;&lt;source src="http://screencasts.b0.upaiyun.com/podcasts/teahour_episode_50.m4a" type="audio/mpeg"&gt;&lt;/source&gt;&lt;/audio&gt;&lt;/p&gt;

&lt;h3&gt;Part 1 - HackerNews Meetup&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：大家好，欢迎收听 Teahour，我是本期的主持人玎玎。本期由我一个人主持，邀请到了来自英国的 Qubit 公司的工程师董京，来 Teahour 做客。董京，你好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：大家好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：首先你做一个自我介绍吧，让大家来了解一下你的背景。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：我现在在英国时区，大早上爬起来跟叶玎玎聊这些事情还是蛮困难的。因为我平时上班也没有起来这么早。我现在在英国创业公司（&lt;a href="http://www.qubitproducts.com/"&gt;Qubit&lt;/a&gt;），工作了 3 年多了。之前我还有在 F1 赛车和英国电信工作过，都是技术方面的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：OK，我跟你认识其实也挺蛮巧的。你在英国生活了很多年，今年回国，在 Twitter 上联系到我，说想组织一个活动——是上海的 &lt;a href="http://hnshanghai.com/"&gt;Hacker News 的线下聚会&lt;/a&gt;。当初你是怎么想到回国时组织这样一个活动呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：我个人虽然比较了解海外的创业市场，但是对中国的创业的环境几乎完全不了解。我在回国的时候想去了解一下，但是发现没有太多渠道或者机会去找聚会。所以我就突然想到，干脆我就自己从头到尾组织一个，找各个公司去 sponsor，自己一个人去联系 speaker。这其实还是蛮有趣的一个经历。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：对，我感觉这次活动也办得...&lt;/p&gt;</summary>
    <content type="html">&lt;blockquote&gt;
  目前 Teahour 的网站不适合放文本，需要重新设计，暂时先放我自己博客上。
&lt;/blockquote&gt;

&lt;p&gt;本文是 Teahour 第 50 期 &lt;a href="http://teahour.fm/2014/04/08/interview-with-dong-jing.html"&gt;『和Qubit的工程师聊聊A/B testing, Node 和 Ruby』&lt;/a&gt; 的录音文本，欢迎大家订阅 Teahour，iTunes URL 是 &lt;a href="http://itunes.apple.com/cn/podcast/teahour.fm/id608387170?l=en"&gt;http://itunes.apple.com/cn/podcast/teahour.fm/id608387170?l=en&lt;/a&gt;。Android 用户可以使用 &lt;a href="http://m.coolapk.com/apk/de.danoeh.antennapod"&gt;AntennaPod&lt;/a&gt; 来订阅。同时，欢迎加 Teahour 好友，&lt;a href="http://weibo.com/teahourfm"&gt;微博&lt;/a&gt;和 &lt;a href="https://twitter.com/teahourfm"&gt;Twitter&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;audio controls name="media"&gt;
  &lt;source src="http://screencasts.b0.upaiyun.com/podcasts/teahour_episode_50.m4a" type="audio/mpeg"&gt;
&lt;/audio&gt;&lt;/p&gt;

&lt;h3&gt;Part 1 - HackerNews Meetup&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：大家好，欢迎收听 Teahour，我是本期的主持人玎玎。本期由我一个人主持，邀请到了来自英国的 Qubit 公司的工程师董京，来 Teahour 做客。董京，你好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：大家好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：首先你做一个自我介绍吧，让大家来了解一下你的背景。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：我现在在英国时区，大早上爬起来跟叶玎玎聊这些事情还是蛮困难的。因为我平时上班也没有起来这么早。我现在在英国创业公司（&lt;a href="http://www.qubitproducts.com/"&gt;Qubit&lt;/a&gt;），工作了 3 年多了。之前我还有在 F1 赛车和英国电信工作过，都是技术方面的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：OK，我跟你认识其实也挺蛮巧的。你在英国生活了很多年，今年回国，在 Twitter 上联系到我，说想组织一个活动——是上海的 &lt;a href="http://hnshanghai.com/"&gt;Hacker News 的线下聚会&lt;/a&gt;。当初你是怎么想到回国时组织这样一个活动呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：我个人虽然比较了解海外的创业市场，但是对中国的创业的环境几乎完全不了解。我在回国的时候想去了解一下，但是发现没有太多渠道或者机会去找聚会。所以我就突然想到，干脆我就自己从头到尾组织一个，找各个公司去 sponsor，自己一个人去联系 speaker。这其实还是蛮有趣的一个经历。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：对，我感觉这次活动也办得还可以。虽然场地上可能还可以有一些提高，但是总体上来说，你一个人办的也还可以。我记得你一个人联系我后，就自己做了一个页面，也设计得很高大上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：那个页面其实还是蛮搞笑的。如果国内有一个可以组织活动的平台，我希望用那个平台。但是我完全没有找到合适的平台，所以我基本上从头到尾，一个晚上，把后台和前台全部写出来了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：八卦一下，用什么写的？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：后台是用 Node.js 写的。我是这样考虑的，那个服务器很小，我不希望需要用太多的内存，所以我没有选择 &lt;a href="http://rubyonrails.org/"&gt;Rails&lt;/a&gt; 或者是其他大的框架，就是一个很简单的 &lt;a href="http://nodejs.org/"&gt;Node.js&lt;/a&gt; 和 &lt;a href="http://expressjs.com/"&gt;Express&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：听起来你是 Node 和 Rails 双修了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：平时我在工作的时候，这两个东西还是用得非常多的。基本上公司的 Rails 构架都是我一个人，后台大约 70－80% 是我写出来的，大约有 6 - 7 个 Node 服务器在后面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：OK，那 Teahour 听众也了解到我们其实已经往 Node.js 社区偏了。开个玩笑。你在英国会经常参加这样的 meetup 吗？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：对啊，我经常参加。这边的聚会是非常非常多的。你想了解有什么样的 meetup 可以到在国外还是蛮盛行的网站，叫 &lt;a href="http://www.meetup.com/"&gt;meetup.com&lt;/a&gt;。在中国还是可以用的，你可以在上面发现很多很多活动，不光光是技术圈的 meetup。还有些关于个人兴趣爱好的活动可以去。可以在周末或者晚上找到很多活动。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：你觉得参加这些 meetup 对你最大的收获是什么？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：最大的收获是我认识了很多圈内的人。我发现大家还是有这个需求的，但是没有太多的人去组织。从我个人体验来说，从头到尾办一次这样的活动要花费很多的精力。不单单是联系 speaker，我还要组织场地，要提前预定、要提前到场去检查，这不只是一个周末的事，从开始到结束要花至少两个礼拜的时间。晚上还要操很多心，要保证这个活动的宣传要做到位，后续通知要做到位，有很多很多事情要做到位。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：辛苦。你也提到过，月底会组织一个远程的聚会，可能会更加辛苦。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：对。好消息是，我昨天刚和我公司的 CTO 联系过，他说如果公司的 budget 足够，他下个月礼拜五可以跟我确认一下，能不能在六月或者五月回国办一个活动。希望是一个好消息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：OK。我知道你在组织活动的同时，还在为公司寻找一些 deverlopers，同时还提供一个到英国工作的机会。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：是这样，创业的，不管是在美国还是在欧洲，都是非常缺人才的。我们在用各种方法去寻找适合的人才，无论在哪里。像我的同事里，前端和中端的工作组大概有 8 个人，这些人里没有一个是纯英国人。我们中有波兰人、立陶宛人、意大利人，再加上我一个中国人，有很多不同的文化。我们也尝试在美国找工程师，而美国，特别是在硅谷，也是非常非常缺人才。尤其是 startup。有经验的人未必适合做创业的工作。&lt;/p&gt;

&lt;h3&gt;Part 2 - Qubit 产品和技术栈介绍&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：那和我们介绍一下你们公司其实是做什么的？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：我们公司做的方面还是挺多的。其中一个目标就是提高电商在线的销售率。这需要通过很多渠道。大家可能对这个市场不是特别了解，在欧洲和美国的电商都希望自己建立一个品牌。在中国大家都要提高在淘宝上的销售率。而在外国都是要在 Google 这个平台，在搜索引擎这个平台上竞争，竞标从而提高网站的浏览量，然后提高销售率。&lt;/p&gt;

&lt;p&gt;我们主要通过跟踪用户的行为，做一些个性化的需求的调整，从而提高销售率。我们公司一个产品 —— &lt;a href="http://www.qubitproducts.com/tag-management"&gt;OpenTag&lt;/a&gt;，他是可以管理网站用户跟踪标签(Tag/Script)的产品。我们很早进入到这个产业里。大家可能对这个产业不了解，一般来说，这个主要的产业趋势是在网站上跟踪各个用户的行为。比如&lt;a href="https://fengcheco.com"&gt;风车&lt;/a&gt;的网站上面，叶玎玎用到了 &lt;a href="https://mixpanel.com/"&gt;Mixpanel&lt;/a&gt;。对我们来说这只不过是一个提供商 (provider)。OpenTag 是一个平台，可以实时更改它们。可以使用 Mixpanel，或者 &lt;a href="https://www.google.com/analytics/web/"&gt;GA（Google Analytics）&lt;/a&gt;，或者 &lt;a href="https://www.kissmetrics.com/"&gt;KISSMetrics&lt;/a&gt;，即可以实时去更改在线网站跟踪代码，只需要花 5 分钟时间。&lt;/p&gt;

&lt;p&gt;对于电商网站来说，这个需求是非常非常高的。在国内虽然有淘宝，但你完全没有机会在其上做个性化的调整。没有办法了解某个用户的具体信息。而如果你有自己的电商平台，你是完全可以做到的。你可以用第三方的工具，比如说 Mixpanel，或者是 GA，或者 &lt;a href="https://www.optimizely.com/"&gt;Optimizely&lt;/a&gt;，去做一些 A/B testing，去做一些具体的跟踪方案。或者通过一些具体的个性化网站的更改方案。&lt;/p&gt;

&lt;p&gt;但问题是，很多中小型或者中大型的电商的开发过程都由第三方开发的，项目周期是非常长的。比如说一个企业公司——乐购，他需要找一个第三方去更改他的网站——添加一个跟踪代码，这个周期起码需要两到三个月。因为他们需要认证、要 approval，然后再等第三方把这个东西做好，还要再测试。&lt;/p&gt;

&lt;p&gt;通过我们的 OpenTag，这样一个标签管理的工具，我们可以在 5 分钟内把跟踪代码放到网上，可以做各种的逻辑管理。比如用户一定要从 Google Search 进入网站才能启动这个标签，来跟踪这个用户。在这个产业内，我们做得还是非常大的。我们发布一年半以后，Google 才做了他们的 &lt;a href="https://www.google.com/tagmanager/"&gt;Google Tag Manager&lt;/a&gt;，也是可以管理标签的。大家感兴趣的，可以搜一下。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：你们在找怎样的人呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：目前，我们非常缺对 JavaScript 了解非常深入的。我们在面试的时候，自己说了解 JavaScript 的人的理解一般还是比较表面的。可能只懂怎么用 &lt;a href="https://jquery.com/"&gt;jQuery&lt;/a&gt;，写很简单的界面的逻辑。但是我们可能是需要招一些深入了解 JavaScript 的人，比如说了解到 &lt;a href="http://wiki.ecmascript.org/doku.php?id=harmon:specification_drafts"&gt;ES6（ECMAScript 6）&lt;/a&gt; 版本的一些具体的功能有什么，如 &lt;code&gt;class&lt;/code&gt; 和 &lt;code&gt;constructor&lt;/code&gt;，而且要了解整个 JS 的趋势。&lt;/p&gt;

&lt;p&gt;我们面临的问题是什么呢？我们的很多工具直接部署在客户的网站上，他们的环境是完全未知的，所以我们要保证在各种情况下面我们的代码都可以在客户的网站上运行。这是一件非常非常难的事情。我举一个非常简单的例子，是我们曾遇到一个非常狗血的问题。大家原来应该用到过一个比较老的框架—— &lt;a href="http://prototypejs.org/"&gt;Prototype JS&lt;/a&gt;。很多电商的网站运用这些陈旧的JS库，会自动 overrides window.JSON 上的方法。而我们经常会处理一些 JSON 数据，而它在 serialize 和 deserialize 的时候处理大的 JSON 非常低效，还会经常出错。特别是 JSON 中有 nested array 时它就完全不能处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：对，然后你们是怎么解决这些问题的？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：我们有自己的一个测试平台，在内部里面可以每天晚上实时运行一些 JavaScript 测试代码，调用各种不同的开发环境在客户的网站上运行，通过测试来达到部署前的测试和部署之后的监控测试，遇到问题之后具体个别处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：OK，听起来就是说你们对 JS 的要求还是比较高的。是比较纯粹的 JS 开发。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：对，是一个 full cycle，因为我们通过跟踪用户，是通过 JS 来的。然后再回到后台，整理用户数据。但我们另一个目标是如何通过行动来改变在线销售率。很多做分析的网站，比如 GA，或者 Mixpanel，他们的目标倾向于分析。但在很多情况下，分析完之后，如果要做行动、要怎么样改进一个网站还是一个未知数。我们的目标是提供一个简单的解决方案来帮用户提高销售率。我们偏向于行动，不仅有数据分析，而且还有工具可以评价如何让你尽快的做实实在在的更改。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：这一点我还是挺有兴趣了解的。如你提的问题，GA 也好， Mixpanel 也好，他只是告诉你了一个数据，比如这个页面到下一个页面的 flow 转换了多少，用户访问了哪些东西。而我确实知道了一些问题，但是如何解决这些问题。我只能去猜，只能去试，之后看转化率有没有提高。你说用了一些解决方案，能大概举一些例子吗？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：我们大部分的客户都是电商，所以很多解决方案都是跟电商相关的东西。比如说一些客户的网站上，用一些 personalized 的方案。是在 homepage 上面提醒明天会下雨，以此接近用户。帮助产品重新做一个包装，让他们可以比较贴近用户一些。这是其中一种方案。另外一种方案，是在一些产品上面显示是不是已经快没有存货了。比如只有两到三个存货的时候，我们可以做一个界面上的更改，提醒用户，这个产品有很多人买，已经只剩下两个货物了，你是不是要买它。经过测试，根据用户的个性和需求，再加上产品的销售量提示会增加很多销售量。比如一个产品的销量提高 2%。&lt;/p&gt;

&lt;p&gt;对于大多数的电商来说，2% 的提高是非常大的。我们的客户有 &lt;a href="https://www.arcadiagroup.co.uk/"&gt;Arcadia Group&lt;/a&gt;，其中一个出名品牌叫做 &lt;a href="http://www.topshop.com/"&gt;Topshop&lt;/a&gt;，是专门给女孩子卖衣服的。如果提高百分之二的销售率对它来说是非常有利的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：了解。你们做的是电商垂直，所以你们说有关于电商的很多数据。通过这个数据提供一些建议。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：对。我们一个未公开但是已经部署的产品也倾向于 enterprise。如果要做比较的话，我拿 &lt;a href="https://www.strikingly.com/"&gt;Strikingly&lt;/a&gt;来作例子。大家应该对 Strikingly 比较熟悉，是蛮有趣的，由中国人开发的产品，但是被 YC 投资了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：是我们已前的嘉宾。『&lt;a href="http://teahour.fm/2013/08/21/strikingly-yc-and-startup.html"&gt;28期：和Strikingly的CTO Dafeng聊聊他们和Y-Combinator的故事&lt;/a&gt;』&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：对。以我个人的见解来说，他们的产品与外国的一个产品叫做 &lt;a href="https://webflow.com/"&gt;Webflow&lt;/a&gt;，是非常非常像的。而且我觉得，Webflow 稍微做的比 Strikingly 专业一些，有很多页面调整的功能是可以更改的，UI 界面也做的非常好。我不知道他们解决的是一个什么问题。对于我来说，Webflow 和 Strikingly 是二十一世纪的 FrontPage。他们把 FrontPage 移到了网络上，但是没有解决用户的需求。如果我是开发人员，我绝对不会去用 Webflow 或 Strikingly 去做网站。我有能力去用 offline 的工具开发，而且我觉得更加顺手，所以我不需要用他们的工具。如果我是一个 designer 的话，我也不太会用这个平台，我会用 PS，或者是其他的 offline 的工具。对一个不懂设计的人用这个网站，你也不能完全保证，他能把这个网站做到怎么好。就是说，这两个产品都是在一个中间层，面对的用户都不是特别的确定。所以我对这种产品稍微有一点怀疑。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：这里说一下我自己的见解。他们的用户群是很确定的。开发设计网页需要一个比较好的 layout，让有美感的，但是不会做网页的人，去做自己的设计。他适合用于展示页面，比如说演员或者模特，他知道怎样的东西是好看的，但是他不会做网页，他可以通过拖拽加一些东西做一些很好看的网页。包括一些摄影的、一些学生。学生可能要给自己做很简单的网站，包括一些页面，来做产品的展示。他有比较确定的用户群体。这类用户是想做网站，而没有做网站的开发能力，所以要找一个相对来说比较简单的工具。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：所以是他本身有一些设计的功底，或者一些设计的天分，然后只要把这个页面做好，再加上内容展示。在商业角度上来说，我可能觉得这一部分虽然还是有机会挣钱的，但不是特别多。毕竟以我的背景来说，我更倾向于 enterprise ，这些小的商业模式赚得钱可能会少一些。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：OK，这个可能就不太确定了。我觉得应该发展得很好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：其实我还是蛮喜欢的。我们公司有个产品还是类似于他们的。我们对整个网络有另外一种看法，所有的网站设计趋势都是忘组件化发展的。大部分网站都是可以按模块来算的。不管是图像、文字、段落、复杂的 animation，或者是 slide，都是按模块来算的，你不能跳出模块。我们是以这个角度看待网站开发的。&lt;/p&gt;

&lt;p&gt;我们的一个解决方案叫 Deliver，通过分析更改网站的任何一个 component。对于一个开发者，专业地开发一个方案，放到市场上。然后市场的人通过调用开发人员已经开发过的方案部署到网站上面。这样就完全做到专业的人可以用专业的线下工具开发，再用我们的接口模块和工具，指出这个组件在哪个网站可以运作，能够提高多少销售率。对于那些非专业，没有太多 design、设计方面天赋的人就可以通过 drag-drop 来测试一下这个组件是不是对电商的品牌有利。&lt;/p&gt;

&lt;p&gt;这个产业——做 A/B testing 还是有很多公司的。另外一个做得比较好的叫做 Optimizely。我不知道叶玎玎有没用过这工具。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：我觉得好贵。（&lt;small&gt;&lt;em&gt;作者注: 记错产品价格了，Optimizely 的价格还是比较合适的&lt;/em&gt;&lt;/small&gt;）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：如果想用免费的工具，Google 还是有一个这样的工具的，也有 A/B testing 的功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：说起 A/B testing ，你们是怎么做的呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：我们的结构非常复杂。你想了解前端还是后端？做 A/B testing，主要靠 JavaScript，实时地替换页面。有 50% 的人可以看到 B 的页面，有 50% 的人可以看到 A 的页面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：我比较贪心一点，想了解前后端。我想去尝试一下，但是没有实战的经验，时间上也不太允许。但我想学习这方面的知识。你们是做分析的，还给用户提供建议，对于怎样更好地提高转化率，你们自己也会很多的 A/B testing 吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：恩，是的。我们内部也做了蛮多的 A/B testing。我们会用自己的工具去做。但还要通过从非专业和非技术的角度上去改善产品。比如我们的产品经理会假设，如果这个页面的模块更改成什么样子，也许会提高百分之多少的销售率，或者达到目标。这个目标需要自己定义。对电商来说，我的目标就是用户买完东西，到最后的 checkout page，然后到 payment，最后 confirmation。但是对于其他用户来说，可能希望用户到注册页面、希望更多的人填自己的邮件地址，subscribe 我的信件。也可能是，让大家点击一个链接，或者是滚动页面到最下面的位置。可以有很多不同的目标，所以要有不同的途径去实现目标。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：那一般来说在前端，根据目标可能会有不同的板式，或者不同的操作过程。那你们是如何保证样本的独立性？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：大部分跟踪是通过 cookie 的，一般都是用 first party cookie。在欧洲，用第三方的 cookie 有很多限制，不能做太多的跨域名跟踪。一般都是在同一个域名下做跟踪。当这个用户第一次登上这个网站之后，会有一个自己的 id。其实可以在淘宝上看到，登陆后用户会有一个 cookie ip。再具体点，用户每一个动作会发到我们的服务器上，我们有一系列的后台运算。我们有专门的做数学模型的博士在我们公司做运算模型。通过运算模型，再把数据发到后台。我们用 &lt;a href="https://hive.apache.org/"&gt;Hive&lt;/a&gt;、&lt;a href="https://hadoop.apache.org/"&gt;Hadoop&lt;/a&gt;、&lt;a href="https://storm.incubator.apache.org/"&gt;Storm&lt;/a&gt;，来做一些实时的分析。这还是一件非常困难的事情。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：再请教一下，你们后台的 A/B testing 是对前台做一个限制还是怎样？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：用 cookie 去实现 A/B testing，其实还是很 limit 的一种方式。大部分企业用户需要了解整个用户的全部的浏览历史。比如说我们有很多用户的数据，来预测一个用户一生会在网站上消费多少。通过这些分析，才能做一些具体的 A/B testing。比如说我要测试一些用户，这些用户的一生会在这个网站上花超过 1000 英镑，针对这些用户，我们再做一些具体的 A/B testing。给他一些优惠，给他一些 promotion，让这些用户群体上受到一些特别的待遇来测试。我们需要通过跟踪，通过一些后台的数据分析用户的历史。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：相当于不是在代码级别的分片，而是对于一些过去行为在后台计算得到结果，推算他会不会做出一个购买行为。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：对我们公司来说，前台后台还是区别蛮大的。如果说前台工作的话，不光光包括前端代码，还包括 middle stack ，全部都要做。对于我自己来说，我平时的工作都是从写 &lt;a href="http://puppetlabs.com/"&gt;Puppet&lt;/a&gt; 开始。如果大家不是很了解的话，就是管理服务器的脚本。从管理服务器开始，到 application logic 再写到前端，是一个非常辛苦的工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：全栈。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：恩。要切换自己的一个 context 还是非常困难的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：你们现在开发有多少人？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：我刚加入的时候整个公司就一层楼，大概有 28 个人。现在公司已经有两层楼了，整个公司从美国到英国到法国还有德国加起来一共有将近 90 个人，工程师可能占一半的数量。前端工程师有将近 10 个，包括 manager。其他人都是做后台的。后台这部分，我们在欧洲还是做得非常大的。按数量来算，我们每天要收到 1.6 个亿的数据点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：这么大的数据是怎么处理的。介绍一下你们存储这方面？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：我不能介绍太多，因为我不是主要做这个方面的。我可以从层面上说一下。如果你了解 Mixpanel 的数据模型，他们没有数据结构的，都是通过 event 来做的，会比较简单 (scalability的原因)。这个行业里大家都要跟踪用户行为，但是没有一个公司去定义一个数据结构。之前我参加了一个项目，是由我们公司首先提出的一个 standard，让大家都是要这个数据结构。运用这个电商数据结构提高跟踪的效率、跟踪代码的更改效率，这样你可以从不同的平台上做切换，也可以更好的做一些网站应用的 implementation。&lt;/p&gt;

&lt;p&gt;我们这个 specification 叫做 &lt;a href="http://www.w3cdigitaldatatoolkit.com/"&gt;Universal Variable&lt;/a&gt;，这个通用变量里有描述到用户的行为，页面的产品，页面的 type/category，比如是 homepage、产品的页面、checkout、basket（购物篮）。这个 spec 已经被列入到 W3C，你可以在 GitHub 上看到 &lt;a href="https://github.com/QubitProducts/UniversalVariable"&gt;specficaiton&lt;/a&gt;。有很多公司都是参加到了这个 spec 的审评的过程，有W3C、Google、IBM。当然还包括我们的 Qubit，也是主要的项目 leader。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：那你能简单介绍 Qubit 的后台用到了什么？你刚才说每天有 Billion 级的数据，如何 scale？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：我们有很多 data center，大部分都是在 Amazon 上面。最早是前台的 JS 发数据到后台，接收这个数据。接收端最早是用 Node 写的。当时我们大概可以 handle 的数量在几百万这样。当时 Node 版本是 0.4。在去年，我们做了一个实验，把它换到 &lt;a href="http://jbossas.jboss.org/"&gt;JBoss&lt;/a&gt; 上，才 handle 到 billion 上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;： handle billion 是指每天的接收的 data point？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：对。还是不需要太多的 backup server 才能做到。到后面我们发现 Node 很难 debug，经常有一些 memory 的问题。特别是在早期 0.4、0.6 的时候。虽然接收数据、forwarding 很简单，但是做了实验后还是放到了 Java 平台上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：还是 Java 更靠谱一点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：对。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：你们有尝试最新版的 Node 吗？测过最大的时候能达到什么程度？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：没有尝试过，因为大家都很忙。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：已经受伤了是吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：对。然后从接收数据到这个模块，再存到 HDFS 上面。之后我们有一个程序把这些数据实时发布到 Hbase、Storm 和 Hive。再做一些运算，根据具体的数据结构的需求把它写入到 Hive 里面，再通过 Storm 和 Hbase 做一些量的分析。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：OK，听起来主要是 Hbase 做数据库存储，Hive 做类 SQL 查询这样的东西。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：其实中间还有很多的技术。比如说 &lt;a href="https://cassandra.apache.org/"&gt;Cassandra&lt;/a&gt;，做一些 queue 的处理。我们原先用 Cassandra 遇到了一些蛮奇怪的问题，说实在没有办法用下去了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：能吐槽一下么？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：这个我就不能吐槽了，也是听别人说的。这么大的数据玩起来还是挺有意思的。有很多 challege。因为这些数据还是有很多 noise 的，所以要做很多测试、删除，包括有一些 bots，垃圾信息，全部都要隔离开。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：那有个问题我想了解，你们拿到数据后处理，到最后得到的结果有多少延时？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：大概做到 5 - 10 分钟。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：那计算还是相当快的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：相当快。我们在 Amazon 上面就有将近 300 台服务器。而且不包括 &lt;a href="https://aws.amazon.com/ec2/spot-instances/"&gt;Spot Instance&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：这个就不是一般人能玩的了。你之前聊到 Node 和 Ruby，特别是你是团队里面唯一一个用 Ruby 的，而其他人都在用 Node？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：可能这样说有点太过了，可能公司里 10 个人有 2 - 3 个会 Ruby。但是根据实际情况，我们的工作主要和 JavaScript 有关，所以 JS 的开发人员相对多一些。总体倾向于 Node.js。一般同事只懂一个语言，就是 JavaScript。也不是说这样不好，大家都用自己知道的东西做事。对实现功能和 startup，也没有太多的不好。用自己不习惯的语言做一些实现功能，毕竟不会做得特别好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：那你们有这么多人，为什么还坚持换到 Java？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：因为写数据接收的那一块是属于后台的工作，而不是属于前台的工作。我们前台主要是做一些产品方面。后台存储处理和前台关系不大。&lt;/p&gt;

&lt;h3&gt;Part 3 - Ruby、Node 的比较和欧洲创业社区&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：难得碰到一个 Node 和 Ruby 双修的。我们在&lt;a href="http://teahour.fm/2014/02/24/first-nodejs.html"&gt;以前（45期：和《深入浅出Node.js》作者朴灵一起聊聊Node.js）&lt;/a&gt;采访朴灵的时候，由我和 Terry 两人主持。而我们对 Node 都不太了解，只好让朴灵来说。你两边都玩，那么你对这两个语言怎么看？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：我个人还是比较偏向 Ruby 的，希望 Ruby 稍微给一点力。但是以现在的趋势来说，Node 的还是很有希望的。比如 ES6 的 sppec，发展趋势蛮好。但是我对这个社区不是特别感兴趣。虽然有层出不穷的 library，但是真正写得好的还是很少，特别是做过单元测试的。但是有一些好东西，比如 ES6 添加了很多编程语言的功能，比如 &lt;code&gt;constructor&lt;/code&gt;，可以写 OOP。Node 可以做 kernel work、annotation 和 dependency injection，慢慢成熟。我前两天还看到有些人在 ES6 上写了一些 spec——怎么样让 Node 实现多线程，实现平行计算。还是很有希望的社群。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：有没有感觉，在欧洲 Node 社区在不断发展，Ruby 社区有点相对 go down？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：有这个趋势。但是我在跟很多创业公司谈的时候，大部分创业的人还是在用 Ruby。有个比较大的创业公司叫 &lt;a href="https://state.com/"&gt;state.com&lt;/a&gt;，他的投资方是因特网之父(Tim Berners-Lee)。这个公司在英国，我之前也和他们开发人员聊过。他们用 Ruby，也用 Node.js。Node.js 不做太多后台的数据处理，主要倾向于前台的渲染。state 做的不是 single page project，需要考虑 SEO。但是通过 Node 做一些优化。大部分的后台的 API 都还是用 Rails 写的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：这个挺有意思的。Node 在中间，然后在前端后端，相对于在中间做了一个桥。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：其实我们公司差不多也是这样类似的构架，我们虽然没有利用 Node 做 SEO，但是我之前说过大概有 6 - 7 个程序，6 - 7 个 logic 都是在用 Node 写的。比如一个 proxy 是用 Node 写出来的。但是也是非常困难，我们需要为此做一些 process management。Node 是一个 single event loop，要保证程序 crash 以后不会影响到其他的用户，需要做很多高端的优化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：了解。这个是 single event loop 的缺点。说到英国的创业环境，我想要了解一下。我可能知道的不多，但是像我们风车在用的 &lt;a href="http://pusher.com/"&gt;Pusher&lt;/a&gt;，支付上用的 &lt;a href="https://stripe.com/"&gt;Stripe&lt;/a&gt;，都是英国的创业公司。所以英国的创业公司是怎样的？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：英国的创业环境应该是很好的，大家的趋势都是互帮互助。我发现一个非常好的现象，大部分有创业精神的人，都不是从天而降的一个点子，而是从自己的需求开始。有一个比较出名的打出租车的公司叫 &lt;a href="https://hailocab.com/london"&gt;Hailo&lt;/a&gt;，在英国是一个做的比较大的公司。它是用手机打车的一个工具。我之前和他们聊的时候，他们的需求也是从自身的需求开始的。这个创业者，家里两代人都是开出租车的。一开始宣传的时候都是从自己家人开始宣传的。比如说我爸爸，我妈妈他们都需要提高载客的时间，从这个地方开始宣传的。&lt;/p&gt;

&lt;p&gt;还有一些比较好玩的，是在欧洲的一个建立旅游行程的工具，叫 &lt;a href="http://citymapper.com/london"&gt;CityMapper&lt;/a&gt;。用来标记从这个地点怎么坐公交车、坐地铁到另外一个地点。这个需求也是从自身开始。原来没有什么工具能做到很准确的推送和预测，他就从头到尾写了这样一个工具。到后来，这样一个工具，在法国和纽约都比较热门。我身边的朋友都在用这个工具。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：那英国的创业环境和欧盟的其他国家比起来怎么样？我弄欧盟签证的时候，除了英国不行，其他都行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：去欧盟其他国家其实还是蛮方便的。你可以申请法国的签证。法国属于欧盟，会给你一个比较长时间的签证，然后用欧盟的多入境的签证，1 年的时间内可以在欧盟里随便进出。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：但是，除了英国。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：对，除了英国。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：这很头疼。那对于整个欧洲来说，英国的整个创业环境处在哪一个层次？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：我不敢说其他城市，伦敦的环境还是非常好的。在伦敦有很多很棒的创业公司。非常非常多，我都没有办法数了。我原来参加活动的时候，和一个人在台下聊过，1 年后他已经在台上聊自己的产品了。所以我真的很佩服外国人。他们实在是太有魄力了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：既然你们考虑在国内招人，然后让他人肉翻墙。那么介绍一下英国的衣食住行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：衣食住行的话，一般来说，做工程师的话，工资都是在 30000 英镑/年。一般的初级工程师是这个价格。最贵的东西是房租和交通，吃饭上花的钱不是特别多。我觉得在上海吃饭的价格跟英国差不多了。但是伦敦的房租很贵，地铁也很贵。大概的价格是这样的。我现在一室一厅的房子的房租大概是 1000 朝上一个月。英国地铁是分区的，从 1 区到 6 区。我买了 1 区到 2 区的地铁票，包月是 120 英镑。地铁票每年都在涨价，去年是 116/月，今年是 120/月。所以说这都是大头。吃饭的话一个月如果你比较省的话，大概 500 英镑以下就可以做到。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：按照你这个介绍的话，junior 的工资是 30000 英镑/年吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：我找工作的时候对银行和金融没有特别感兴趣。如果做金融的话，junior 的工资相对高一些，大概是 40000 英镑朝上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：国内的很多程序员真的非常优秀。如果是 senior 的话，在英国的收入能达到怎样的水平？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：senior 的话，当然不能跟 Facebook 比，至少在 60000 英镑朝上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：所以可以给国内一些人参考。现在人肉翻墙是一个很火的话题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：特别是上海，上海这个天气，真的是没有办法形容。因为我是2月2日回上海的，那个飞机要迫降到厦门然后再到厦门，就是因为雾霾，整个飞机晚点了 6 个小时。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：但是伦敦比上海就少了一个霾，雾还是有的嘛。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：雾其实没有很多，但是雨很多，我在回上海的时候差不多一个月没有见过太阳。冬天一直在下雨。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：像 Qubit 来说，待了 3 年多，是家创业公司，之前你提到 F1，在英国电信有过工作经历，所以我想了解你在 F1 干嘛了？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：我之前在 F1 做了两个赛季，主要是帮他们写一些赛车策略上的软件。看赛车的话，国内应该还是有很多 F1 的 fans。从专业角度上看，F1 要看策略。看策略还是蛮有意思的。在欧洲有一些电视台，他们有一些策略的软件，能提前预测，赛车的油要加多少，轮胎要换什么样子，driver 是怎么开车的。每个赛车队都是有自己的一套软件的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：你在哪个赛车队？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：我之前在雷诺，现在车队改名叫莲花。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：你相当于做策略分析？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：帮他们提供一些软件。做策略分析要专业的策略分析师。但我在层面上还是有一些了解的。每个车队都有一些历史数据，包括每个赛车手开车的习惯是什么，如 &lt;a href="https://en.wikipedia.org/wiki/Lewis_Hamilton"&gt;Lewis Hamilton&lt;/a&gt; 他打弯的时候是非常用力的，有一边的轮胎在磨损上比其他赛车手要高一些。数据接收的话，大部分赛车预测的数据都是实时给出。有一个公司叫 FOM（Formula One Management有限公司），他们提供整个比赛的规则和数据。大部分数据都是和时间有关，比如车子通过每一个赛道的时间是多少，他跑到第几圈。在赛外知道这件事情，还是非常 surprise 的。他们可以通过非常简单的一个时间数据就可以从头到尾了解到这个 driver 的 performance，包括其他车手的 performance。还是蛮有趣的一个工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：听起来是科技改变赛车。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：这有件搞笑的事。虽然看起来他很高端，但当年的时候，那些数据都是靠人工提供的。有一个人在赛道拿着一个计时器，每辆赛车跑过的时候他都会按一下计时器。但是现在会好一点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：你有没上去玩过？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：我没有上去过。不过我之前的办公室是在雷诺的一个工厂里面，在一个很偏僻，没有人烟的地方。上班如果骑车或者开车，只能看到一些动物，比如狐狸，梅花鹿，总之就是很偏僻的小山村。之前雷诺的工场分了两个。一个是在英国，一个是在法国。法国主要是造引擎的。英国是造车架的，包括整个车子的外框、车头。就是前翼、后翼和车身。英国这里还包括提供一些软件更新。那时候我的办公室楼下就是组装的地方。每个车队都要准备 4 辆车，2 个给 driver，另外两台给车手赛前预备。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：想想都觉得酷。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：基本上每天下午都要试引擎。每天 5 点钟之后，在我办公室下面要开引擎热车，那声音非常非常响。他们加了消音器之后，声音还是非常非常响。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：不过从这段经历啊，到你后面的东西，都是在和数据打交道。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：都是在这个产业里做的。不知道怎么可以脱离这个行业。我对数据处理，怎么样让用户了解怎么去使用数据的了解还是比较多的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：其实不用脱离啊，我觉得这块现在很好。大数据其实很火。那你在学校是学什么的呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：我是 Computer science 的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：你是在计算机专业里偏数据这一块吗？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：偏理论一些。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：你在英国待了多久？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：差不多 10 个年头了吧。然后 5 年学习，5 年工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：相当于在英国读了个大学就开始工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：大学本科和硕士，然后再工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：英国本硕只要 5 年。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：本科是 4 年，硕士 1 年。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：硕士在英国只需要 1 年，还是你学的比较快？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：只要 1 年。我是在帝国理工攻读的硕士。在帝国理工，学硕士是非常折磨人的。帝国理工是一个蛮有名以工程著名的学校，毕业率是非常低。如果你学 EE，或者是 CS，基本上毕业率在 60%。我第一次接触 Ruby 的时候是在 2008 年，还是比较早的。我记得 08 年那时候，Ruby 的版本是 1.8，Rails 刚出到 2。我大学的一个学长，他是一个很不淡定的人。他毕业的时候，一直想做一个创业公司，一个 social network。他找到我，说，“那好吧，那我们要用什么来写？”他可能想写 PHP，而我又是一个 hipster 的人，想学一个新的语言。当时我就比较喜欢 Ruby，所以就很莫名其妙的看了这一套东西。所以说就帮他做了一点东西。但是他当时对这个东西不是特别感兴趣。所以我跟他就是因为兴趣不合，就分开来了，也祝福他能把东西做好。后来我在大学毕业论文的时候，就写了一套 social network。我对这个东西还是蛮感兴趣的，就用 Rails 构架了一个 social network，有点像 Facebook，有点像 forum。像一个论坛，但是这个论坛里可以构架一些 apps。我记得当时在论文里写了一些关于 BDD 的东西。我还是蛮早的时候就接触了这一套东西。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：刚才你提到了一些 Node 不是特别舒服的地方，比如不太注重工程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：我可能是片面的了解了。大部分写前端代码的人，没有太多的后端的经验。当然有些工程师有，但是他们没有太多后端的经历的话，对于一些具体的比较工程类的构架或者是怎么样能写出可以维护的代码不太了解。但都是因人而异。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：我们原来采访了朴灵嘛，朴灵也提到了类似的观点。把 Node 用得比较好的，都是来自后端的人。他们在后端有一些比较强的 background，到了前端这块，他们的整个思维会带过来。真正做得好的，能推进 Node 的可能会是后端的这些人。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：非常同意。&lt;/p&gt;

&lt;h3&gt;Part 4 - Share Picks&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：今天非常感谢你这么早起来录这一期的 Teahour，今天的节目就到这里为止。下面就是我们 Teahour 的一个例行环节，叫 short picks。Short picks 就是你可以任意分享一个你觉得有意思的东西，或者想玩的东西，或者在看的一本书。你先来？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：好吧。我说的可能会稍微长一点。我的兴趣还是蛮多的。去年我大概花了 1 年的去玩多轴飞行器。我推荐大家去看看这个公司，叫做 &lt;a href="http://store.3drobotics.com/"&gt;3DR（3DRobotics）&lt;/a&gt;，是 Chris Anderson 开的一个专门做飞行器的公司。最近这个主题还是蛮流行的。最近的新闻中 Facebook 要做他们自己的飞行器。而之前 Amazon 也有用他们自己的飞行器做一些货物的 delivery。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：自动送货。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：这一方面是一个趋势。我对这个方面也是蛮感兴趣的。大家可以看一下 3DR。和一个最新的飞行控制器的平台，叫 &lt;a href="http://3drobotics.com/pixhawk/"&gt;Pixhawk&lt;/a&gt;。这个飞行控制器是一个非常好的 32 位飞行控制器。之前的都是 8 位的，而这个控制器可以做平行计算，可以加非常多的感光器件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：没有图片，我没法想象。我看过一种，是 4 个圆组成的方，每一个圆里有一个机扇的那种。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：差不多吧。他是分多轴的嘛。你可以选 4 个，选 6 个。如果大家看《爸爸去哪儿》，他们拍摄的时候都是用那个拍的。他在空中拍摄都是用四轴拍的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：你等一下可以给我一张你在玩那个的照片。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：我可以给一个链接给大家看我是怎么把它&lt;a href="http://instagram.com/p/fI1EzmPbGW/"&gt;摔坏的录像&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：好的。这个我没玩过，我不太了解。但是我在外面看别人玩过，是挺好玩的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：这个东西还算是蛮贵的。我有一个理想就是退休后读一个博士，往这个方向读。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：好吧。听你这么介绍，是可编程的吗？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：对，是可编程的。这个社区还是蛮大的。有不同版本的飞行控制器，有几个比较有名的，有一个叫 ??。有一个法国人，他把任天堂 Wii Remote 的 controller 全部拆掉，然后把它改成了一个飞控的平衡控制器。在另外一个社区 3DR，他们专门造的一个飞行控制器，叫 APM。也是一个非常有名的飞行控制器。最近他们发布的一个 Pixhawk，这个新的控制器可以用Lua编译代码。之前老的都是要写类似于 C 的代码，通过 Arduino 来编译的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：什么时候让我看看你那个摔坏的视频能不能打动我，我也想尝试一下。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：玩这个要注意安全，还是蛮危险的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：也就是说这个不太适合给小孩子当玩具。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：不太适合，这个东西不是属于玩具类的，是属于“杀伤性武器”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：好的，OK。那我放弃这个想法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：你可以买一些很简单的，还有一些玩具类的，不需要太多的调试就可以飞的那些。那些还是可以做玩具的。它有一些小的飞行控制器，大概有手掌那么大吧。还是可以给小孩子玩玩的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：我觉得小孩子应该还是挺喜欢玩得。谢谢介绍。还有没有其他的？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：没有了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：OK，那今天我的 picks 是一个软件。最近 Google 停止支持 Gmail Notifier 了。那我向大家推荐一个我朋友写的软件，叫 &lt;a href="http://ashchan.com/projects/gmail-notifr"&gt;Gmail Notifr&lt;/a&gt;，是一个 open source 的在 Mac 上的客户端。很多人的工作习惯都会例行处理邮件。有的时候，我们看到一个邮件提醒，让我们知道大概什么东西发过来了。但是我们不会想实时的去检查，而是每隔一小时两小时，让它自动去检查一下，然后告诉我邮箱里有邮件。所以说用一个 Gmail Notifr，会比较简单的一点，让你觉得工作的更加高效。所以我就推荐一下我朋友写的，我自己在用的不错的软件，叫做—— Gmail Notifr。在 Mac App Store 可以下载。大家可以来支持一下，尝试一下。当然他也是开源的，你可以免费下载。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：那不错，我记得在回国的时候，由于我很多的邮件都是在 Gmail 上，访问起来非常慢。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：对。而且用 web 的话会更加慢，用客户端会好很多。IMAP 还好一点。OK，这就是我今天的 picks，最后非常感谢董京来到我们的 Teahour 做客，希望下一次有机会可以在跟你深入聊一下 Qubit 用到的东西。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：可以啊。然后还要告诉大家一下，希望大家期待正在计划组织下一次 Hacker News Meetup。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：顺便说一说，因为你现在正在招人。你可以留个邮箱，让大家可以直接联系你。我相信会有很多人听了这期节目会对加入你们的团队有兴趣。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：好的。或者大家可以在微博上&lt;a href="http://www.weibo.com/u/2462586132"&gt;@我&lt;/a&gt;，我就会看到。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：好，那就这样？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：好。谢谢。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;叶玎玎&lt;/strong&gt;：88&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;董京&lt;/strong&gt;：88&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>YOU should write!</title>
    <link rel="alternate" href="/2014/04/29/you-should-write.html"/>
    <id>/2014/04/29/you-should-write.html</id>
    <published>2014-04-29T04:00:00Z</published>
    <updated>2014-04-29T04:00:00Z</updated>
    <author>
      <name>叶玎玎</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;aside class="aside"&gt;
    &lt;img alt="Writing" src="/images/you-should-write/writing.jpg?1398745718" /&gt;
&lt;/aside&gt;&lt;/p&gt;

&lt;p&gt;上周的 &lt;a href="http://teahour.fm/2014/04/28/the-story-of-jianshu.html"&gt;Teahour.FM&lt;/a&gt; 迎来了两大内容平台的创业者做客，简书的创使人林立和 Logdown 的创始人 xdite。在节目中，林立和 xdite 分享了他们做内容平台的想法。最近五六年是社交网络的天下，各种社交应用的爆发同时也把人们带入了碎片化时代，尤其是 140 字的限制，使得人们在快速生产内容，快速消费内容，越来越少的人愿意沉下心思考，记录一些文字。我们的生活其实少了很多精彩，所以很高兴能看到这一年间内容平台重新兴起并且回归，&lt;a href="https://medium.com/"&gt;Medium&lt;/a&gt;、&lt;a href="http://jianshu.io/"&gt;简书&lt;/a&gt;、&lt;a href="http://logdown.com/"&gt;Logdown&lt;/a&gt;、&lt;a href="http://ghost.org/"&gt;Ghost&lt;/a&gt; 等，每天去看看简书或者 Logdown 里面的推荐文章，我相信一定会有被感动的时候。&lt;/p&gt;

&lt;p&gt;节目中问了一下 xdite 一年的产出是多少，直接被吓到了。在做 Logdown 之前 xdite 已经达到了年写 400000 字，平均一天 1100 字，做 Logdown 之后是只多不少，对于一个创业者、技术开发人员而非作家来说，我必须得说是非常惊人的数字，当然在这个产出下，获得的回报也是惊人的，比起之前写的一篇文章就给 Logdown 带来了 30 万的 PV。&lt;/p&gt;

&lt;p&gt;37signals 曾在其畅销书 『Getting Real』 中提到，招聘时，永远选候选人中写得更好的，无论是设计师、程序员、运营人员、销售还是其他。写得好的人也必然同时更善于思考和沟通，所以也能更好的与代码和人打交道。&lt;/p&gt;

&lt;p&gt;程序员大多都很痛恨写文档，尤其是写那些认为没用的文档，继而懒得记录自己的思考和心得。我们在 teahour 也聊到这点，理解但非常推荐开发人员多写文字，坚持写作对个人成长带来的好处是你无法估量的。我自己在团队中，每一个功能发布，都是要求负责人直接去写发布博客，不但要会实现，还是能给用户讲明白前因后果。&lt;/p&gt;

&lt;p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;aside class="aside"&gt;
    &lt;img alt="Writing" src="/images/you-should-write/writing.jpg?1398745718" /&gt;
&lt;/aside&gt;&lt;/p&gt;

&lt;p&gt;上周的 &lt;a href="http://teahour.fm/2014/04/28/the-story-of-jianshu.html"&gt;Teahour.FM&lt;/a&gt; 迎来了两大内容平台的创业者做客，简书的创使人林立和 Logdown 的创始人 xdite。在节目中，林立和 xdite 分享了他们做内容平台的想法。最近五六年是社交网络的天下，各种社交应用的爆发同时也把人们带入了碎片化时代，尤其是 140 字的限制，使得人们在快速生产内容，快速消费内容，越来越少的人愿意沉下心思考，记录一些文字。我们的生活其实少了很多精彩，所以很高兴能看到这一年间内容平台重新兴起并且回归，&lt;a href="https://medium.com/"&gt;Medium&lt;/a&gt;、&lt;a href="http://jianshu.io/"&gt;简书&lt;/a&gt;、&lt;a href="http://logdown.com/"&gt;Logdown&lt;/a&gt;、&lt;a href="http://ghost.org/"&gt;Ghost&lt;/a&gt; 等，每天去看看简书或者 Logdown 里面的推荐文章，我相信一定会有被感动的时候。&lt;/p&gt;

&lt;p&gt;节目中问了一下 xdite 一年的产出是多少，直接被吓到了。在做 Logdown 之前 xdite 已经达到了年写 400000 字，平均一天 1100 字，做 Logdown 之后是只多不少，对于一个创业者、技术开发人员而非作家来说，我必须得说是非常惊人的数字，当然在这个产出下，获得的回报也是惊人的，比起之前写的一篇文章就给 Logdown 带来了 30 万的 PV。&lt;/p&gt;

&lt;p&gt;37signals 曾在其畅销书 『Getting Real』 中提到，招聘时，永远选候选人中写得更好的，无论是设计师、程序员、运营人员、销售还是其他。写得好的人也必然同时更善于思考和沟通，所以也能更好的与代码和人打交道。&lt;/p&gt;

&lt;p&gt;程序员大多都很痛恨写文档，尤其是写那些认为没用的文档，继而懒得记录自己的思考和心得。我们在 teahour 也聊到这点，理解但非常推荐开发人员多写文字，坚持写作对个人成长带来的好处是你无法估量的。我自己在团队中，每一个功能发布，都是要求负责人直接去写发布博客，不但要会实现，还是能给用户讲明白前因后果。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;相信每个写作的人都曾有体会，当你提笔去解释一个东西的时候，你以为你知道的事情未必真正知道。写作并不只是简单的记录，而是需要让读者也能跟着你的思路，理解你想表达的东西。所以，要想非常清晰的表达你的观点，写作必然是一次知识体系的重新学习和思绪的梳理，这样才能帮助读者理解。而这个过程，才是你真正的收获。&lt;/p&gt;

&lt;p&gt;写作也是你个人品牌建立和传播的非常有效的方式。永远不要低估文字的影响力和传播力，总会有人因为你的文字而受益。当你分享越来越多的思考和知识，人们会了解到你的个性，了解到你的为人和处事方式。不管是否会有人因此讨厌你，请相信一定会有更多的人喜欢你，他们会因为你的内容继而了解你在做的事情，比如在写的一本书，在做的一个产品，等等。而这些东西会也因为你的品牌而具有同样独特的个性。&lt;/p&gt;

&lt;p&gt;程序员在开源的世界里以码会友，在思想的世界里以文会友。无论是 teahour 还是我的博客文章，在这一年多都给我带来了很多的好朋友，一些甚至在生活中都不可能有任何交集的朋友。人的成长就在于不停的扩大自己的圈子并对等的交流，接触到这么一群非常有思想的人，从这些朋友身上学习到很多东西，才是我最大的收获。&lt;/p&gt;

&lt;p&gt;在分享知识的同时，它可能也会节省你很多时间，比如也许你 Google 到的一个解决方案就是你之前写过的一篇文章。去年在 Teahour 时也问过 xdite 这么高产的背后是如何寻找到写作的主题的。xdite 解释说有很多是很多人重复在问她的问题，她觉得累了，不想花时间一一回答，就把它写了出来让提问者直接去阅读，这样既可以让读者更系统的了解，也能节省大把的时间。&lt;/p&gt;

&lt;p&gt;所以，YOU should write!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;“我没时间写东西”&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“我不知道写什么”&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“我没什么有价值的好写的”&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;aside class="aside"&gt;
    &lt;img alt="Writing Process" src="/images/you-should-write/mindnode.png?1399041455" /&gt;
&lt;/aside&gt;&lt;/p&gt;

&lt;p&gt;不要再给自己找借口了，放轻松点，我们不是作家要写一部小说，我们只是作者要写点东西，而如前面所言，写作能让我们梳理整个知识体系，这就够了。Medium 的 slogan 我觉得非常好，『Everyone&amp;rsquo;s stories and ideas』，我们每天都在接收新的信息和新的想法，为何不把它记录成字呢？不要一开始就苛求完美，永远记得&lt;strong&gt;坏的开始就等于成功的一半&lt;/strong&gt;。我觉得我写的每一篇初稿都很烂，但是每次修改都让我觉得比前一次好一点点。到最后发布时，看起来也还不错，至少自己挺满意。&lt;/p&gt;

&lt;p&gt;细细分析，写作的整个过程其实跟做产品还蛮像的。一篇文章的出炉，需要历经计划、调研、初稿、复审、修订和发布的过程。做计划时需要了解文章读者是谁，他们的期望是什么，确定主题思想。调研时比较同类文章，梳理整个思路。一般在这个阶段后，我已经基本有了一个脑图。初稿就严格按照脑图需求，迅速成文。之后听取朋友反馈，多次修订，最后发布。整就一个精益写作的过程。&lt;/p&gt;

&lt;p&gt;写作是一个非常值得培养的习惯。这个技能的练成，没有捷径，唯有不停的练习。时代在回归，人也要回归。千里之行，始于足下，YOU should get started!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Test Your MVP, Seriously</title>
    <link rel="alternate" href="/2014/04/17/test-your-mvp-seriously.html"/>
    <id>/2014/04/17/test-your-mvp-seriously.html</id>
    <published>2014-04-17T07:00:00Z</published>
    <updated>2014-04-17T07:00:00Z</updated>
    <author>
      <name>叶玎玎</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;aside class="aside"&gt;
  &lt;img alt="Crossing the Chasm" src="/images/test-your-mvp-seriously/mvp.png?1397752296" /&gt;
&lt;/aside&gt;&lt;/p&gt;

&lt;p&gt;最近 MetaLabs 既 Flow 之后正式对外发布了一款面向团队的新产品 &lt;a href="http://www.usepeak.com/"&gt;Peak&lt;/a&gt;，看着挺吸引人，所以准备去玩玩看。不过当我进入注册页面后，我犹豫了，相对冗长的信息填写，还要求信用卡信息，再回去看看定价方案，必须年费支付，思考了一会，最后打了退堂鼓。我们做产品的都会有一个共识，尽可能的降低用户的进入门槛，减少注册路径，让用户能尽快的了解产品的特色。而这里 Peak 是反其道而行之，我相信跟我一样因为犹豫最后放弃了的访问会不在少数。但是细细思考后，这种验证 MVP 的方法真好！&lt;/p&gt;

&lt;p&gt;精益创业的核心是以最低的成本做出最小可行产品（MVP），小步验证快速迭代。这里面很难的一点是，怎样才算『最小可行』产品，即使同一个团队每个人心中的答案可能都不太一样，所以最后只能由用户说话。Peak 和我现在在做的风车一样，都属于企业服务，所以最好的验证方式就是用户用&lt;strong&gt;真金白银&lt;/strong&gt;来实际支持你，变成了客户。只有这样，我们才能知道到底是不是在正确的道路上，我们提供的解决方式是否具有足够的价值。国外的企业服务在产品刚推出期间经常会用类似的进入方式，如 14-天免费试用、信用卡准入、年费支付、甚至还有预付等等。我很喜欢这种方式，商业社会从第一天开始，其本质和基础就是建立在价值交换上，你给我提供了价值，我付给你钱，就这么简单。所以，从一开始就开始以吸纳客户为目的的 MVP 验证方式在我看来非常正确，反观国内，不知从何时起，得屌丝者得天下之论甚行，大多创业者喜欢跑马圈地，先把用户圈起来，然后想着总有一天有机会来剪羊毛。然而，可惜的是，绝大多数的创业团队，都撑不到那一天。&lt;/p&gt;

&lt;p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;aside class="aside"&gt;
  &lt;img alt="Crossing the Chasm" src="/images/test-your-mvp-seriously/mvp.png?1397752296" /&gt;
&lt;/aside&gt;&lt;/p&gt;

&lt;p&gt;最近 MetaLabs 既 Flow 之后正式对外发布了一款面向团队的新产品 &lt;a href="http://www.usepeak.com/"&gt;Peak&lt;/a&gt;，看着挺吸引人，所以准备去玩玩看。不过当我进入注册页面后，我犹豫了，相对冗长的信息填写，还要求信用卡信息，再回去看看定价方案，必须年费支付，思考了一会，最后打了退堂鼓。我们做产品的都会有一个共识，尽可能的降低用户的进入门槛，减少注册路径，让用户能尽快的了解产品的特色。而这里 Peak 是反其道而行之，我相信跟我一样因为犹豫最后放弃了的访问会不在少数。但是细细思考后，这种验证 MVP 的方法真好！&lt;/p&gt;

&lt;p&gt;精益创业的核心是以最低的成本做出最小可行产品（MVP），小步验证快速迭代。这里面很难的一点是，怎样才算『最小可行』产品，即使同一个团队每个人心中的答案可能都不太一样，所以最后只能由用户说话。Peak 和我现在在做的风车一样，都属于企业服务，所以最好的验证方式就是用户用&lt;strong&gt;真金白银&lt;/strong&gt;来实际支持你，变成了客户。只有这样，我们才能知道到底是不是在正确的道路上，我们提供的解决方式是否具有足够的价值。国外的企业服务在产品刚推出期间经常会用类似的进入方式，如 14-天免费试用、信用卡准入、年费支付、甚至还有预付等等。我很喜欢这种方式，商业社会从第一天开始，其本质和基础就是建立在价值交换上，你给我提供了价值，我付给你钱，就这么简单。所以，从一开始就开始以吸纳客户为目的的 MVP 验证方式在我看来非常正确，反观国内，不知从何时起，得屌丝者得天下之论甚行，大多创业者喜欢跑马圈地，先把用户圈起来，然后想着总有一天有机会来剪羊毛。然而，可惜的是，绝大多数的创业团队，都撑不到那一天。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;aside class="aside"&gt;
  &lt;img alt="High-Tech Product Life-Cycle" src="/images/test-your-mvp-seriously/product-lifecycle.png?1399041455" /&gt;
&lt;/aside&gt;&lt;/p&gt;

&lt;p&gt;Geoffrey A. Moore 在其经典著作 『&lt;a href="http://en.wikipedia.org/wiki/Crossing_the_Chasm"&gt;Crossing the Chasm&lt;/a&gt; 』 里，提出了技术产品的生命周期定律，在天使用户和早期大众用户之间有一条很难跨越的鸿沟。结合精益创业的思想，MVP 迭代的做法正是为了能尽可能的去跨过去，可以说，MVP 是给天使用户而做，验证想法修正迭代以期最后改进成适合早期大众用户的真正产品。所以，一定要非常严肃的对待 MVP，而其中关键又是从用户那里得到足够的反馈。然而，既然我们需要用户，需要反馈，那是不是甩开膀子，用免费的方式，有足够的眼球和吆喝就可以了呢？很不幸的是，绝大部分情况下，不是。大量的免费用户也意味着大量的噪音，你得从中找到真正的意见，找到真正用户愿意付钱的点和用户不关心的点。回到价值交换上，用户之所以愿意掏钱成为客户的原因是你的产品的某个价值，越早的了解这个价值并有针对性的去放大这个价值会越助于你跨越鸿沟。想想以下一些场景，是否感觉很熟悉？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有用户告诉你：&amp;quot;你的产品做的很棒，是我见过做得最好的。&amp;quot;&lt;/li&gt;
&lt;li&gt;有用户告诉你：&amp;quot;我一直都很想做一个这样的工具，现在你们做出来了，太好了。&amp;quot;&lt;/li&gt;
&lt;li&gt;有用户告诉你：&amp;quot;第一次使用感觉非常舒服，体验非常好，很适合我们。&amp;quot;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;等等，这些是我在做『&lt;a href="https://fengcheco.com"&gt;风车&lt;/a&gt;』时从一些用户那里听到的，但是很不幸的是，说喜欢和花钱购买是两个天差地别的行为，好多这样友好的用户到最后都没有成为客户，也就只能让你在那个瞬间自我满足一下。更糟的是，有些用户可能还会给你一些混淆视听的意见，比如觉得如果有哪些哪些功能会更好。如果你好好的研究过用户，你会发现一件很好玩的事，就是用户和客户对应用的改进意见会有很大的不同。所以，最好的验证 MVP 方式不是看是否有足够大的用户量进来，而是有多少用户真正的需要你的产品并为之付费。一个产品从付费客户开始，会让你更好的了解你产品对于别人的价值，即使没有人愿意付费也是给你一个非常好的调整信号。所以，像 Peak 这种在产品推出之初，增加进入的门槛，让真正对 Peak 提供的解决方案感兴趣的潜在客户进来，在我看来是一种非常正确和值得学习的方式。&lt;/p&gt;

&lt;p&gt;不知为啥，每次我跟一些人介绍风车是收费的时候，整个气氛就会突然变尴尬，好像收费是非常可耻的行为是的。尤其是喜欢开源的技术人员，更会觉得谈钱比较伤感情，只要能做一个别人喜欢用的产品，而不在乎能不能有钱赚。可惜商业是残酷的，没什么好在意的，我反而觉得免费是最偷懒和最懦弱的做法。&amp;quot;Stop talking, take my money&amp;quot; 是很多产品人做产品梦想遇到的事情，但是却很多时候藏着掖着，最后为了如何从免费用户那里赚钱想尽办法，甚至于直接去卖用户了，违背了一开始做产品的初衷。所以，如果你做的产品是一个为别人提供价值的产品，比如企业工具类，请放心大胆的，从第一天开始，就慎重考虑是否免费。如果你连收费都不敢，凭什么让我相信你不是玩一下见势不对就跑路的态度，那时时间比起金钱对我来说才是更大的损失。 免费的模式固然有其很多好处，但是从收费开始会让你更好的了解你的客户，更好的了解你的产品，你也完全可以在后期调整商业模式，提供收费外的其他选择，比如免费增值，但是建立在真正足够了解用户为啥掏钱的原因的基础上。&lt;/p&gt;

&lt;p&gt;收费的另外一个好处是，你的支持成本在初期会降低很多，尤其在本来资源就紧缺的环境下。能提供很好的用户支持一般是创业公司相比较大公司能提供的优势，所以我们无法对一个用户说，因为你没付钱我们就不提供服务或者差一级的服务，每个愿意来花时间提意见的用户都应该得到我们的感谢，不管有多吹毛求疵。所以，这种时候商业模式的区别能帮你省很多力，让你去服务你更愿意服务的客户。&lt;/p&gt;

&lt;p&gt;所有的 MVP 验证行为都是市场行为，依托于大量的假设和验证。你可以通过分析获取隐藏在数据背后的事实，参考『&lt;a href="http://yedingding.com/2014/03/27/growth-from-analytics.html"&gt;创业成长，从分析开始&lt;/a&gt;』，也可以通过与用户交流或者采访来获得真实的反馈。所以，请一定要根据你的 MVP，找到对的人群，严肃的，测试提供的解决方案的价值。如果你认可一个产品给你带来的价值，获益远超过你的付出，也请好好考虑是否购买使用，这不仅仅是支持，也是双赢，更是对整个生态圈的改善。&lt;/p&gt;
</content>
  </entry>
</feed>
